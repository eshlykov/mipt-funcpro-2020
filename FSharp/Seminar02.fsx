// ОСНОВНЫЕ ПРИМИТИВНЫЕ ТИПЫ

// int: -4, 2, ...
// float: 2.3, 4e7, ...
// bool: true, false
// char: 'a', '7', ...
// string: "str", ...
// unit: ()

// -----------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ ЗНАЧЕНИЙ

let intTwo = 2
let floatThree = 3.
let boolTrue = true
let charA = 'A'
let stringHello = "Hello"
let unitValue = ()

// Типы могут быть записаны через двоеточие после имени константы
let intValue : int = 4

// -----------------------------------------------------------------------------
// ОСНОВНЫЕ ОПЕРАТОРЫ

// Арифметические бинарные операции: + - * / % **
// Арифметические унарные операции: + -
// Операторы сравнения: = < > >= <= <>
// Логические операторы: not || &&

let three = 1 + 2
let trueConst = true && true

// -----------------------------------------------------------------------------
// ОБЪЯВЛЕНИЕ ФУНКЦИЙ
let plus x y = x + y
let unaryMinus x = -x
let notEqual x y = x <> y
let logicalAnd x y = x && y

// Для аргументов можно явно указывать типы через двоеточие
let typedPlus (x : int) (y : int) : int = x + y

// -----------------------------------------------------------------------------
// ПРИМЕНЕНИЕ ФУНКЦИЙ

// Для вызова функции аргументы перечисляются перез пробел
let four = plus 1 3
let minusFour1 = unaryMinus four
let minusFour2 = unaryMinus (plus 1 3)

// Операторы - тоже функции. Их можно переписать в виде обычной функции:
printfn "%A" (( * ) 1 3)

// -----------------------------------------------------------------------------
// ВЫВОД В КОНСОЛЬ

// Обычно достаточно функции printfn. У нее переменное число аргументов,
// она реализована на C#. Функция возвращает unit

// Стандартные спецификаторы для форматирования
printfn "%i %f %b %c %s" intTwo floatThree boolTrue charA stringHello

// Спецификаторы для pretty-formatted-вывода - работает медленнее
printfn "%A %A %A %A %A" intTwo floatThree boolTrue charA stringHello

// Наблюдение: значения, они же константы, можно также рассматривать
// как функции без аргументов. Но как сделать функцию, которая не принимает
// аргументов и не является значением? Попробуем
let none = printfn "none" // Напечатали
// Нужен способ заставить при каждом обращении к none печать "none" в консоль
none // Не напечатали
// Это не работает, поскольку значение было вычислено при объявлении и уже
// выведено на экран, а в none сохранился результат - ()

// Для таких целей функции приписывают unit-аргумент
let printNone () = printfn "none" // Не напечатали
printNone () // Напечатали
printNone () // Напечатали
// Обратите внимание, что мы написали не имя аргумента, а сразу значение ()
// В этот аргумент нельзя передать другие значения других типов. А вот такое,
// например, имеет право на жизнь
printNone (printfn "print")

// -----------------------------------------------------------------------------
// КОРТЕЖИ

// Тип кортежа обозначается 'a1 * ... * 'aN, где 'aK - тип k-го элемента
let tuple2 = (unitValue, charA) // : unit * char
let tuple3 = (boolTrue, unitValue, floatThree) // : bool * unit * float

printfn "%A" tuple2
printfn "%A" tuple3

// Доступ к элементам
let first2 = fst tuple2 // Только для пар
let second2 = snd tuple2 // Только для пар
let first3, second3, third3 = tuple3 // Распаковка значений
let _, second, _ = tuple3 // Распаковка значений с отбрасыванием ненужных

// -----------------------------------------------------------------------------
// ФУНКЦИОНАЛЬНЫЕ ТИПЫ

// Тип функции записывается в виде 'a1 -> ... -> 'aN -> 'r
// 'aK - тип k-го аргумента (k = 1 .. n), 'r - тип результата

// Например, plus: int -> int -> int

// -----------------------------------------------------------------------------
// КАРРИРОВАНИЕ

// Каррирование - это подход к описанию функций, в котором функция нескольких
// аргументов реализуется как функция одного аргумента, возвращающая функцию от
// следующего аргумента, возвращающая функцию от следующего аргумента - и так
// далее

// Все функции, которые мы видели выше, реализованы в таком стиле. Его главное
// преимущество - частичное применение функции. Так, можно зафиксировать
// несколько первых аргументов функции, тогда результатом будет функция с
// меньшим числом аргументов
let plusTwo = plus 2 // : int -> int
printfn "%A" (plusTwo 2)

// Отсюда становится ясно, что в функциональном типе стрелка - на самом деле не
// что иное, как оператор над типами, имеющий правую ассоциативность:
// plus : int -> (int -> int)
// То есть plus - это функция от одного числа, которая возвращает функцию от
// числа, которая уже возвращает конечный результат

// Стандартные операторы в языке также следуют этому паттерну, значит, и для них
// доступно частичное применение
let threeMinus = ( - ) 3 // : int -> int
printfn "%A" (threeMinus 7)

// Для реализации функции в обычном стиле, как мы привыкли делать в императивных
// языках, нужно все ее аргументы перечислить в виде кортежа
let plusTupled (x, y) = x + y // : (int * int) -> int

// Иногда каррированием называют и процесс преобразования таких функций к
// каррированному описанию: например, при каррировании функции plusTupled
// получится функция plus

// -----------------------------------------------------------------------------
// ОПЦИОНАЛЬНЫЙ ТИП

// 'T option - тип объекта, который может содержать значение типа 'T, а может
// и не содержать. Объект опционального типа 'T option, содержащий значение x
// типа 'T, обозначаетcя Some x, а объект типа 'T option, не содержаший
// никакого значения - None
let optionalEmpty : int option = None
let optionalNotEmpty = Some 5
printfn "%A" optionalEmpty
printfn "%A" optionalNotEmpty

// Достать значение. Если optionalNotEmpty на самом деле None,
// то выпадет исключение - это побочный эффект, так лучше не делать
let five : int = optionalNotEmpty.Value
printfn "%A" five

// Проверки на пустоту
printfn "%A" optionalEmpty.IsNone
printfn "%A" optionalEmpty.IsSome

// -----------------------------------------------------------------------------
// СПИСКИ

// Списки определяются, используя квадратный скобки
// Внутри через ; перечисляются элементы
let emptyList = [] : int list
let listOf123 = [ 1; 2; 3 ]
let listOf123Multiline = [
    1
    2
    3
]
printfn "%A\n%A\n%A" emptyList listOf123 listOf123Multiline
printfn "%A" (listOf123 = listOf123Multiline)

// Еше один способ - используя конструктор списков
printfn "%A" (1 :: 2 :: 3 :: [])

// Списки можно задавать через диапазоном
let range = [ 1 .. 10 ]
let rangeEmpty = [ 10 .. 1 ]
printfn "%A\n%A" range rangeEmpty

// Можно указывать шаг, причем в середине
let evenDesc = [ 10 .. -2 .. 1 ]
printfn "%A" evenDesc

// Наконец, списки можно задавать генераторами, комбинируя цикл for и yield
let squares = [ for i in 1 .. 10 do yield i * i ]
printfn "%A" squares
// Здесь берется "список" 1 .. 10, из него достается элемент, он подставляется
// в выражение после yield, после чего все эти выражения собираются в новый
// список, который и возвращается в качестве результата

// Запись do yield можно сократить до ->
let cubes = [ for i in 1 .. 10 -> i * i * i ]

// Два списка можно конкатенировать в один через @
printfn "%A" ([1; 2; 3] @ [4; 5; 6])

// Добавить элемент в начало списка можно c помощью ::
printfn "%A" (1 :: [ 0; 2; 3 ])

// Функции для работы со спискам лежат в модуле List
// Вот некоторые из них
printfn "%A" (List.empty)
printfn "%A" (List.append [ 1; 2; 3 ] [4; 5; 6])
printfn "%A" (List.average [ 1.; 2.; 3. ])
printfn "%A" (List.chunkBySize 2 [ 1; 2; 3; 4; 5 ])
printfn "%A" (List.distinct [ 1; 2; 2; 3; 4; 4 ])
printfn "%A" (List.head [ 1; 2; 3 ])
printfn "%A" (List.tail [ 1; 2; 3 ])
printfn "%A" (List.length [ 1; 2; 3 ])
printfn "%A" (List.item 1 [ 1; 2; 3 ])
printfn "%A" (List.contains 1 [ 1; 2; 3 ])
printfn "%A" (List.isEmpty [ 1; 2; 3 ])
printfn "%A" (List.max [ 1; 2; 3 ])
printfn "%A" (List.min [ 1; 2; 3 ])
printfn "%A" (List.rev [ 1; 2; 3 ])
printfn "%A" (List.sort [ 3; 2; 1 ])
printfn "%A" (List.sum [ 1; 2; 3 ])
printfn "%A" (List.truncate 2 [ 1; 2; 3 ])
printfn "%A" (List.zip [ 1; 2; 3 ] [ 'a'; 'b'; 'c' ])
printfn "%A" (List.unzip [ (1, 'a'); (2, 'b'); (3, 'c') ])

// -----------------------------------------------------------------------------
// УСЛОВНОЕ ВЫРАЖЕНИЕ

// В отличие от императивных языков, if является выражением, а не инструкцией,
// то есть он вычисляется и возвращает какое-то значение
let findFirstIndexOf x (tuple : int * int) =
    if fst tuple = x then Some 0
    elif snd tuple = x then Some 1
    else None

printfn "%A" (findFirstIndexOf 3 (3, 3))
printfn "%A" (findFirstIndexOf 3 (3, 4))
printfn "%A" (findFirstIndexOf 3 (5, 3))

// Обратите внимание, что чтобы выражение возвращало значение, должны
// присутствовать обе ветки: then и else. Однако если тип выражения unit, то
// ветку else можно опустить
let tryPrint (x : int option) = if x.IsSome then printfn "%A" x.Value

tryPrint (Some 10)
tryPrint None

// -----------------------------------------------------------------------------
// РЕКУРСИЯ

// Для объявления рекурсивной функции нужно указать ключевое слово rec
let rec factorial n =
    if n <= 0 then 1
    else n * factorial (n - 1)

printfn "%A" (factorial 4)

// С помощью рекурсии можно реализовать цикл for со счетчиком
let rec forLoop counter condition increment body =
    if condition counter then
        body counter
        forLoop (increment counter) condition increment body

forLoop 0 (( > ) 10) (( + ) 1) (printfn "%A")

// -----------------------------------------------------------------------------
// СОПОСТАВЛЕНИЕ С ОБРАЗЦОМ

// Сопоставление с образцом используется для исследования логической структуры
// объектов, их декомпозиции на части или извлечения данных из объектов

// Синтаксис сопоставления с образцом следующий:
// match <expression> with
// | <pattern> [when <condition>] -> <expression>
// ...

// Какие бывают образцы, зависит от типа выражения!

// Литерал: 1, "string", 4.5, []
// Переменная: x, y - можно взять любое имя
// Конструктор списка: x :: xs,  x :: y :: ys, [ 1; 2; 3]
// Конструктор кортежа: (1, 4), (1, (), "string", x :: xs)
// Плейсхолдер: _ - подходит под все объекты

// Образцы могут быть вложенными, как видно из примеров

// Как это выглядит в коде
let isEmpty list =
    match list with
    | [] -> true
    | _ -> false
printfn "%A" (isEmpty [])
printfn "%A" (isEmpty [1])

// Как это работает: берется выражение и по очереди сопоставляется с каждым
// образцом. Значением сопоставления с образцом будет выражение, записанное
// после стрелки для подошедшего образца

// В случае [] видно, что подходит первый образец, поэтому вернется true. Для
// списка [1] пустой список не подходит, поэтому эта ветвь будет пропущена, и
// будет сопоставление с плейсхолдером. Но все выражения подходят под
// плейсхолдер, поэтому вернется false

// Если для выражения не нашлось подходящего образца, то будет брошено
// исключение. Если сопоставление с образцом написано так, что существуют
// объекты, которые не подходят ни под один из образцов, то компилятор может
// выдавать предупреждение

// Некоторые образцы являются неопровержимыми: это плейсхолдер и переменная.
// Если есть такой образец, то сопоставление с образцом безопасно. Лучше
// всегда строить ваши сопоставления таким образом, чтобы последняя ветвь
// была с неопровержимым образцом

// Разобрались с литералами. Идем дальше: добавляем условия
let rec factorial2 n =
    match n with
    | n when n > 0 -> n * factorial2 (n - 1)
    | _ -> 1
// Здесь оба образца неопровержимые, но первое срабатывает только при условии.
// Обратите внимание, что n в образце и n в аргументе функции - разные
// константы! Чтобы не путаться, можно в образце использовать другое имя
let rec factorial3 n =
    match n with
    | m when m > 0 -> m * (factorial (m - 1))
    | _ -> 1
// Здесь в переменную m, определенную в образце m, будет положено значение
// переменной n (потому что сопоставление прошло успешно)

// Конструкторы часто нужны, чтобы извлекать из структуры данных части
let rec sumFirstTwoOpt list =
    match list with
    | x1 :: x2 :: _ -> Some (x1 + x2)
    | _ -> None
// Здесь используется сложный образец - конструктор списка. Каждая из частей
// между двоеточиями также является образцом. Сопоставление с образцом ::
// работает по алгоритму: голова списка сравнивается с образцом до двоеточия,
// а хвост списка сравнивается с частью после двоеточия. Таким образом, в
// x1 будет положена голова списка, а хвост будет сраниваться с образцом
// x2 :: _. Значит, голова хвоста, или второй элемент исходного списка, будет
// сохраннет в x2, а хвост будет проигнорирован, так как плейсхолдер.
// По такому же алгоритму работают и более сложные образцы, например:
// | (5, _) :: (_, '4') :: _ :: (a, b) :: _ -> ()
// Конструктор кортежа работает аналогично: первый
// элемент сорпоставляется с частью до первой запятой, второй - между первой и
// второй и так далее, разумеется, с учетом вложенных образцов

// При сопоставлении с образцом нет возможности делать сравнения: следующая
// функция всегда вернет true
let compare x y =
    match y with
    | x -> true
    | _ -> false

// Теперь, использя условные выражения, рекурсию и сопоставление с образцом,
// напишем быструю сортировку списка
let rec quickSort list =
    match list with
    | [] -> []
    | _ ->
        let left = [ for x in list do if x < (List.head list) then yield x ]
        let right = [ for x in list do if x > (List.head list) then yield x ]
        (quickSort left) @ ((List.head list) :: (quickSort right))

printfn "%A" (quickSort [ 10; 5; 3; 7; 4; 2; 1 ])

// -----------------------------------------------------------------------------
// ЛЯМБДА-ВЫРАЖЕНИЯ

// В языке F# есть два синтаксиса для лямбда-выражений:
let lambda1 = fun x -> x * 2
let lambda2 = function x -> x * 2

// Вторая запись поддержитвает сопоставление с образцом, а первая нет
let tryPopFront = function
| [] -> (None, [])
| x :: xs -> (Some x, xs)

// Это эквивалентно
let tryPopFront' y =
    match y with
    | [] -> (None, [])
    | x :: xs -> (Some x, xs)

// Если функция имеет аргументы, то аргумент function - последний
let pushBackEvenAndPushFrontOdd list = function
| x when x % 2 = 0 -> list @ [x]
| x -> x :: list

printfn "%A" (pushBackEvenAndPushFrontOdd [ 1; 2 ] 1)
printfn "%A" (pushBackEvenAndPushFrontOdd [ 1; 2 ] 2)

// -----------------------------------------------------------------------------
// ФУНКЦИИ ВЫСШИХ ПОРЯДКОВ

// Функция, которая принимает на вход другую функцию, называется функцией
// высшего порядка. Такие функции нужны чаще всего для обработки структур данных
// или некоторых проверок

// Основных функций для работы со списками три
printfn "%A" (List.map (fun x -> x * x) [ 1; 2; 3 ])
printfn "%A" (List.filter (fun x -> x % 2 <> 0) [ 1; 2; 3 ])
printfn "%A" (List.fold (fun acc x -> acc - x) 0 [ 1; 2; 3 ])

// Есть также функция reduce, которая делает то же, что и fold, но в качестве
// аккумулятора берет первый элемент списка. Это делает ее не способной работать
// с пустым списком, поэтому, надо убеждаться что список не пустой. Полезно,
// когда для функции нет нейтрального элемента
printfn "%A" (List.reduce (fun acc x -> acc + x) [ 1; 2; 3 ])

// Другие функции высших порядков
printfn "%A" (List.averageBy (fun x -> x * x) [ 1.; 2.; 3. ])
printfn "%A" (List.collect (fun x -> [ x; x - 1 ]) [ 1; 2; 3 ])
printfn "%A" (List.countBy (fun x -> x % 2) [ 1; 2; 3 ])
printfn "%A" (List.distinctBy (fun x -> x * x) [ 1; -1; 2; -2; 3 ])
printfn "%A" (List.exists (fun x -> x % 2 = 0) [ 1; 2; 3 ])
printfn "%A" (List.find (fun x -> x % 2 = 0) [ 1; 2; 3 ])
printfn "%A" (List.findIndex (fun x -> x % 2 = 0) [ 1; 2; 3 ])
printfn "%A" (List.forall (fun x -> x % 2 = 0) [ 1; 2; 3 ])
printfn "%A" (List.maxBy (fun x -> x * x) [ 1; 2; 3 ])
printfn "%A" (List.minBy (fun x -> x * x) [ 1; 2; 3 ])
printfn "%A" (List.init 3 (fun x -> x * x))
printfn "%A" (List.partition (fun x -> x % 2 = 0) [ 1; 2; 3; 4; 5 ])
printfn "%A" (List.sortBy (fun x -> -x) [ 1; 2; 3 ])
printfn "%A" (List.sumBy (fun x -> -x) [ 1; 2; 3 ])
printfn "%A" (List.tryFind (fun x -> x % 4 = 0) [ 1; 2; 3 ])

// -----------------------------------------------------------------------------
// ОПЕРАТОРЫ ДЛЯ РАБОТЫ С ФУНКЦИЯМИ

// В функциональных языках функции хочется видеть объектами первого класса,
// поэтому для них должны быть доступен набор операторов, позволяющие
// манипулировать функциями разными способами

// Для удобства есть оператор конвейера |>, который берет левую часть и кладет
// ее последним аргументом в правую часть
[ 1; 2; 3 ] |> List.map (fun x -> x * 2) |> printfn "%A"
[ 1; 2; 3 ] |> ignore

[ 1; 2; 3; 4; 5 ]
|> List.map (( - ) 3)
|> List.filter (( <> ) 0)
|> List.reduce ( + )

// Есть вариант конвейера в обратную сторону. Он нужен, чтобы писать меньше
// скобок
printfn "%A" (( + ) 2 <| ( * ) 2 2)
printfn "%A %A %A" <| 2 + 2 <| 3 + 3 <| 4 + 4

// По аналогии есть операторы композиции: >> и <<. Оператор |> принимает функцию
// и значение (которое, конечно, может быть функцией), а композиция - принимает
// две функции. Типы операторов следующие:
// |> : a -> (a -> b) -> b
// <| : (a -> b) -> a -> b
// >> : (a -> b) -> (b -> c) -> a -> c
// << : (a -> b) -> (c -> a) -> c -> b
// Обратите внимание, что это функции высших порядков, поэтому, чтобы отличить,
// где аргумент функции высшего порядка, а где - аргумент функционального
// аргумента, типы группируются в скобки. При этом каждый из типов a, b, c
// также может быть функциональным!

printfn "%A" (((( + ) 2) >> (( * ) 3)) 4) // (4 + 2) * 3
printfn "%A" (((( + ) 2) << (( * ) 3)) 4) // 4 * 3 + 2

// -----------------------------------------------------------------------------
// ПРЕОБРАЗОВАНИЯ ТИПОВ

// Чтобы привести выражение к типу T, нужно применить функцию T. К сожалению,
// такие функции определены не для всех типов
let intThree = int 3.5
let floatFour = float 4
let stringFive = string 5
let charSix = char 54

// Отдельно рассмотрим важное преобразование строки в список символов. Это
// проще всего сделать через for
let stringToCharList (str : string) = [ for c in str -> c ]

// Обратное преобразование чуть сложнее: сначала переводим char'ы в строки,
// затем конкатенируем. Есть и другие варианты
let charListToString = List.fold (fun acc (c : char) -> acc + string c) ""

// -----------------------------------------------------------------------------
// ВВОД С КОНСОЛИ

// Читать с консоли будем с помощью функции Console.ReadLine(), реализованной
// на C#. Для ее использования нужно импортировать модуль System

open System

let line = Console.ReadLine () // Помним, что нужен unit-аргумент для вызова

// That's all folks! Теперь надо научиться этим пользоваться! :)
