{-# LANGUAGE InstanceSigs #-}

module Seminar08 where

import Prelude hiding (
        Functor, fmap, (<$>), (<$),
        Applicative, pure, (<*>), (<*), (*>),
        Traversable, sequenceA, traverse
    )

import Utils

--------------------------------------------------------------------------------
-- ФУНКТОРЫ

-- Ранее мы работали исключительно со списками и рассмотрели базовые функции
-- высшего порядка для него: map, filter, foldr.

-- Позже выяснилось, что функция foldr применима не только к спискам, но и к
-- многим другим типам, которые также можно рассматривать как контейнеры.

-- Оказывается, можно провести параллель, и обобщить не только foldr до списков,
-- но и функцию map.

-- Все однопараметрические типы (то есть с кайндом * -> *) - по смыслу это
-- тип-контейнер и тип-элемент, - для которых можно преобразовывать элементы,
-- сохраняя логическую структуру контейнера, объединяются в класс типов Functor
-- и называются функторами.

-- Сохранение логической структуры проще всего пояснить в случае списков:
-- для них это условие означает всего лишь сохранение длины. В общем случае
-- требования к классу типов формулируются в виде привычных нам законов, которые
-- мы разберем ниже.

-- Определение класса типов состоит из типа f :: * -> * и по сути всего лишь
-- одной функции fmap.
class Functor f where
    fmap :: (a -> b) -> f a -> f b
    -- fmap принимает функцию и контейнер с элементами, тип которых  совпадает с
    -- типом аргумента функции; а на выходе получается тот же самый контейнер,
    -- но с элеметнами нового типа. Нетрудно догадаться, какой по смыслу должна
    -- быть реализация. :)

    -- Можно смотреть на функцию fmap по-другому:
    -- fmap :: (a -> b) -> (f a -> f b)
    -- Таким образом, функция fmap принимает функцию над элементами контейнера
    -- и возвращает новую функцию, которая принимает уже контейнер. То есть
    -- запись fmap f :: f a -> f b - это та же функция f, но поднятая с уровня
    -- элемента контейнеров на уровень целых контейнеров.

    -- Кроме того, функторы содержат еще усеченный оператор (<$), имеющий
    -- следующую реализацию по умолчанию:
    (<$) :: b -> f a -> f b
    y <$ xs = fmap (const y) xs
    -- Он, сохраняя струкутуру контейнера, заменяет все элементы этого
    -- контейнера на заданный элемент.

-- В модуле Prelude есть инфиксный аналог функции fmap: (<$>).
(<$>) :: Functor f => (a -> b) -> f a -> f b
(<$>) = fmap
infixl 4 <$>

-- А в модуле Data.Functor есть симметричный усеченный оператор:
($>) :: Functor f => f a -> b -> f b
($>) = flip (<$)

--------------------------------------------------------------------------------
-- ЗАКОНЫ ДЛЯ ФУНКТОРОВ

-- Сохранение сткрутуры контейнера определяется через выполнение двух законов:
-- * fmap id = id
-- * fmap (f . g) = fmap f . fmap g

-- Первый закон говорит о том, что если функцию id :: a -> a вывести на уровень
-- контейнеров f, то получится функция id :: f a -> f a на контейнерах.

-- Второй закон гласит, что применить к контейнеру композиицю двух функций - то
-- же самое, что применить них последовательно.

-- Таким образом, последовательные функции fmap могут быть более эффективно
-- выполнены через fmap, чем пользуется компилятор для оптимизации нашего кода.

-- Есть любопытный момент: в Haskell из второго закона следует первый.

--------------------------------------------------------------------------------
-- БИБЛИОТЕЧНЫЕ ФУНКТОРЫ

-- Первый функтор, с которым мы уже на самом деле знакомы, это список:
instance Functor [] where
    fmap :: (a -> b) -> [a] -> [b]
    fmap = map
    -- Для функции map из стандартной библиотеки нет такого сюрприза, что на
    -- самом деле она реализована в каком-то классе типов. Обычный map сразу
    -- функция над списками, поэтому для реализации функтора прекрасно подходит.

    -- Напоминание:
    -- map f (x : xs) = f x : map f xs
    -- map _ _        = []

-- Хотя список и самый известный функтор для нас, он на самом деле и один из
-- самых сложных, поскольку определение списка рекурсивно. Значит, доказывать
-- выполнение законов нужно индукцией.

-- Для Maybe сохранение структуры означает, что если контейнер был Nothing,
-- то он Nothing и останется, а если был Just, то тогда к элементу применится f
-- и вернется новый Just:
instance Functor Maybe where
    fmap :: (a -> b) -> Maybe a -> Maybe b
    fmap f = maybe Nothing (Just . f)
    -- Напоминание:
    -- maybe :: b -> (a -> b) -> Maybe a -> b
    -- maybe _ f (Just x) = f x
    -- maybe y _ _        = y

-- Так как кайнд функторов * -> *, то для Either нужно проделать тот же трюк,
-- что мы делали с Foldable: зафиксировать первый элемент. Тогда все сработает
-- по аналогии с Maybe:
instance Functor (Either a) where
    fmap :: (b -> c) -> Either a b -> Either a c
    fmap f = either Left (Right . f)
    -- Напоминание:
    -- either :: (a -> c) -> (b -> c) -> Either a b -> c
    -- either _ f (Right x) = f x
    -- either g _ (Left y)  = g y

-- Аналогично для пар: фиксируем первый аргумент, а второй меняем:
instance Functor ((,) a) where
    fmap :: (b -> c) -> (a, b) -> (a, c)
    fmap f (y, x) = (y, f x)

-- Наконец, функции с зафиксированным первым аргументом также являются
-- функторами:
instance Functor ((->) e) where
    fmap :: (a -> b) -> (e -> a) -> (e -> b)
    fmap = (.)

    -- По смыслу это ((->) e) здесь уже не контейнер, а вычисление в некотором
    -- окружении e. Таким образом, fmap превращает функцию f в новую функцию,
    -- которая может работать с некоторым контекстом. В будущем на этой идее
    -- будет реализована монада Reader.

    -- Поскольку здесь инстантс весьма абстрактным, давайте ручками проверим
    -- выполнение обоих законов. Первый закон:
    -- * fmap id =
    -- = \ f -> fmap id f =
    -- = \ f -> id . f =
    -- = \ f -> \ x -> (id . f) x =
    -- = \ f -> \ x -> id (f x) =
    -- = \ f -> \ x -> f x =
    -- = \ f -> f
    -- = id.
    -- Второй закон:
    -- * fmap (f . g) =
    -- = \ h ->  fmap (f . g) h =
    -- = \ h -> (f . g) . h =
    -- = \ h -> f . (g . h) =
    -- = \ h -> fmap f (g . h) =
    -- = \ h -> fmap f (fmap g h) =
    -- = \ h -> (fmap f . fmap g) h =
    -- = fmap f . fmap g.
    -- Что и требовалось доказать.

--------------------------------------------------------------------------------
-- АППЛИКАТИВНЫЕ ФУНКТОРЫ

-- У функторов есть небольшое ограничение: нет возможности "мапать" контейнер
-- с помощью функций нескольких аргументов.

-- Действительно, было бы удобно, имея, скажем, f :: a -> b -> c, получить
-- функцию "fmap" f :: f a -> f b -> f c, но, используя функторы, мы получим
-- разве что fmap f :: f a -> f (b -> c).

-- На самом деле это важный шаг к тому, чего мы хотим. Теперь понятно, что если
-- реализовать функцию ap :: f (b -> c) -> f b -> f c, то мы получим как раз  то,
-- что хотели: ap . fmap f :: f a -> f b -> f c. Более того, с ее помощью делать
-- обобщение на функции большего числа аргументов.

-- Смысл функции ap :: f (b -> c) -> (f b -> f c) в том, что мы по контейнеру
-- функций получаем функцию, которая работает уже над контейнерами.

-- Функция ap в виде оператора (<*>) вводится в классе типов Applicative, то
-- есть классе аппликативных функторов. Аппликативный функтор расширяет
-- понятие функутора, добавляя в него дополнительные функции:
class Functor f => Applicative f where
    -- Та самая функция ap.
    (<*>) :: f (a -> b) -> f a -> f b
    infixl 4 <*> -- Тот же приоритет и ассоциативность, что у (<$>).

    -- Следующая функция позволяет возвести элемент в контейнер.
    pure :: a -> f a
    -- По смыслу это контейнер из одного элемента, например, [x] или Just x.
    -- Самый-самый-самый примитивный способ упаковать в контейнер единственный
    -- элемент.

    -- Кроме того, есть функция liftA2, которая как раз делает то, что мы
    -- хотели, когда придумывали аппликативный функтор. У нее есть реализация
    -- по умолчанию:
    liftA2 :: (a -> b -> c) -> f a -> f b -> f c
    liftA2 f xs ys = f <$> xs <*> ys

    -- Наконец, есть половинки оператора (<*>). У них есть дефолтные реализации:
    (<*) :: f a -> f b -> f a
    (<*) = liftA2 const
    infixl 4 <*

    (*>) :: f a -> f b -> f b
    as *> bs = (id <$ as) <*> bs
    infixl 4 *>
    -- Их мы обсудим чуть ниже, после того как наработаем интуицию о том, что
    -- такое аппликативные функторы.

    -- На самом деле и оператора (<*>) есть реализация по умолчанию:
    (<*>) = liftA2 id
    -- Дейтсвительно, по типам все сходится:
    -- liftA2 (id :: (b -> c) -> (b -> c)) :: f (b -> c) -> f b -> f c.

    -- Таким образом, минимальная полная реализация аппликативного функтора
    -- состоит из двух функций: либо { pure, (<*>) }, либо { pure, liftA2 }.

-- Замечание: на самом деле функция ap тоже существует, но она определена не для
-- аппликативных функторов, а для монад, которые в свою очередь расширяют
-- понятие аппликативных функторов.

--------------------------------------------------------------------------------
-- БИБЛИОТЕЧНЫЕ АППЛИКАТИВНЫЕ ФУНКТОРЫ

-- Мы знаем пока что только 5 библиотечных функторов; оказывается, каждый из
-- них также является и аппликативным функтором.

-- Самый простой аппликативный функтор - это Maybe.
instance Applicative Maybe where
    pure :: a -> Maybe a
    pure = Just
    -- pure идейно - простейший способ положить значение в контейнер. В случае
    -- с Maybe - просто обернуть в Just.

    (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
    Just f <*> mx = f <$> mx
    _      <*> _  = Nothing
    -- Здесь ничего удивительного: если функции или аргумента нет, то и
    -- результата нет, а если оба присутствует, то в контейнер кладем
    -- результат. Только здесь мы используем инфиксный fmap - оператор (<$>),
    -- который протаскивает функций через mx :: Maybe a.

-- Точно с той же идеей работает и аппликативный функтор Either a для
-- произвольного типа a:
instance Applicative (Either a) where
    pure :: b -> Either a b
    pure = Right

    (<*>) :: Either a (b -> c) -> Either a b -> Either a c
    Right f <*> ex = f <$> ex
    Left y  <*> _  = Left y

-- Немного сложнее выглядит аппликативный функтор для пары. Дело в том, что
-- (,) :: * -> * -> *, то есть нужно первый аргумент зафиксировать, как и в
-- Either. Как тогда реализовать pure для пары, если нужно что-то положить в
-- первый элемент пары? Для этого на первый элемент накладывается ограчение -
-- он должен быть моноидом:
instance Monoid a => Applicative ((,) a) where
    pure :: b -> (a, b)
    pure x = (mempty, x)
    -- В качестве самого простого первого элемента пары берем нейтральный
    -- элемент моноида.

    (<*>) :: (a, b -> c) -> (a, b) -> (a, c)
    (y1, f) <*> (y2, x) = (y1 <> y2, f x)
    -- А для первого элемента в аппликативном применении - используем операцию
    -- из полугруппы. Принцип именно такой, а не y1 или y2, так как в будущем
    -- эта идея будет использоваться нами для реализации монады Writer.

-- Еще сложнее выглядит аппликативный функтор для функциональной стрелки:
instance Applicative ((->) e) where
    -- Обратите внимание, как переписывается тип:
    pure :: a -> e -> a
    pure = const
    -- Самый простой способ получить функцию, возвращающую элемент, - это
    -- функция const. Действительно, переписав в более привычный вид, имеем:
    -- pure x = \ _ -> x.
    -- Так как мы ничего не знаем про тип e, то лучшее, что с ним можно сделать
    -- со значением, это проигнорировать его (можно еще вернуть, но это бы
    -- не подошло по типу).

    (<*>) :: (e -> a -> b) -> (e -> a) -> e -> b
    f <*> x = \ e -> f e (x e)
    -- Если расставить скобки по правой ассоциативности конструктора (->), то
    -- получится, что f <*> x - это функция из e в b. Реализуем ее в виде
    -- лямбды. Тогда аргумент можно использовать для извлечения функции a -> b
    -- и просто a, ну и применить одно к другому.

-- Список хотя и проще функциональной стрелки, но его семантика может показаться
-- непривычной:
instance Applicative [] where
    pure :: a -> [a]
    pure x = [x]
    -- Положить элемент в список проще всего вот так. Формально можно было бы
    -- и несколько раз, но это был бы не самый примитивный способ.

    (<*>) :: [a -> b] -> [a] -> [b]
    fs <*> xs = [ f x | f <- fs, x <- xs ]
    -- Здесь важно, что мы применяем каждую функцию к каждому результату, а не
    -- просто uncurry ($) <$> zip fs xs. То есть
    -- [f1, f2] <*> [x1, x2] = [f1 x1, f1 x2, f2 x1, f2 x2], не [f1 x1, f2 x2].

--------------------------------------------------------------------------------
-- ЗАКОНЫ ДЛЯ АППЛИКАТИВНЫХ ФУНКТОРОВ

-- Для аппликативных функторов должно быть выполнено 4 закона.
-- 1. pure id <*> xs = xs                                -- Identity
-- 2. pure f <*> pure x = pure (f x)                     -- Homomorphism
-- 3. fs <*> pure x = pure ($ x) <*> fs                  -- Interchange
-- 4. pure (.) <*> fs <*> gs <*> xs = fs <*> (gs <*> xs) -- Composition

-- Identity говорит о том, что контейнер из единственной функции id при
-- применении к контейнеру xs не меняет ни структуру xs, ни сами элементы xs,
-- то есть xs остается неизменным.

-- Закон гомоморфизма утверждает, что аппликативное применение контейнера из
-- единственной функции к тому же контейнеру из единственного аргумента
-- возвращает контейнер из результата обычного применения функции к элементу.

-- Interchange говорит, что операция аппликативного применения в некотором
-- смысле коммутативна: действительно, при применении контейнера функций к
-- контейнеру из одного элемента должен получится тот же результат, что и при
-- применении контейнера из одной функции `применить x` к тому же самому
-- контейнеру функций. Возможно, чуть более понятно будет запись без сечения:
-- fs <*> pure x = pure (\ f -> f x) <*> fs.

-- Мы еще вернемся к упоминанию фундаментальной важности этого закона, когда
-- будем говорить о монадах.

-- Закон композиции указывает в некотором смысле определение композиции. Есть
-- неаппликативный аналог: (f . g) x = f (g x).

-- Рассмотрим леву часть закона: если у нас есть два контейнера функций, и мы
-- хотим их применить к контейнеру аргументов, то надо сначала связать их
-- композицией, а затем применить к аргументам. Так, мы сначала применили fs к
-- gs композицией, а затем полученный контейнер композиций применяем к xs.

-- И оказывается, это то же самое, что и правая часть, где мы применяем
-- контейнер fs уже к результату аппликативного применения gs к xs.

--------------------------------------------------------------------------------
-- АППЛИКАТИВНЫЙ ФУНКТОР MAYBE

-- Начнем разбираться по очереди с каждым из аппликативных функторов, чтобы
-- хоть немного понять, что это такое и зачем оно нужно.

-- Начнем со всех возможных комбинаций самого простого аппликативного функтора:
_ = pure True              `is` Just True
_ = Just (^ 2) <*> Just 3  `is` Just 9
_ = Just (^ 2) <*> Nothing `is` Nothing
_ = Nothing    <*> Just 3  `is` Nothing
_ = Nothing    <*> Nothing `is` Nothing

-- Но на всякий случай убедимся в выполнении всех законов для Applicative Maybe:

-- 1. pure id <*> xs = xs -- Identity
_ = \ x -> pure id <*> Just x `is` Just id <*> Just x
_ =        pure id <*> Nothing `is` Nothing

-- 2. pure f <*> pure x = pure (f x) -- Homomorphism
_ = \ f x -> pure f <*> pure x `is` Just f <*> Just x `is` Just (f x)
_ = \ f x -> pure (f x) `is` Just (f x)

-- 3. fs <*> pure x = pure ($ x) <*> fs -- Interchange
_ = \ f x -> Just f <*> pure x `is` Just f <*> Just x `is` Just (f x)
_ = \ f x -> pure ($ x) <*> Just f `is` Just ($ x) <*> Just f `is` Just (f x)
-- Если fs - Nothing, то ясно, что с обеих сторон сразу же получится Nothing.

-- 4. pure (.) <*> fs <*> gs <*> xs = fs <*> (gs <*> xs) -- Composition
_ = \ f g x -> pure (.) <*> Just f <*> Just g <*> Just x `is`
               Just (.) <*> Just f <*> Just g <*> Just x `is`
               Just (f .) <*> Just g <*> Just x `is`
               Just (f . g) <*> Just x `is` Just (f (g x))

_ = \ f g x -> Just f <*> (Just g <*> Just x) `is` Just f <*> Just (g x) `is`
               Just (f (g x))
-- Если что-то из этого Nothing, то ясно, что вся цепочка будет Nothing, так
-- что проверять не будем.

--------------------------------------------------------------------------------
-- АППЛИКАТИВНЫЙ ФУНКТОР EITHER

-- Как мы уже говорили, Either работает примерно так же, как и Maybe, только
-- вместо конструктора Nothing используется Left с каким угодно значением, а
-- если Left с обеих сторон оператора (<*>), то берется первый из них.
_ = pure True                `is` Right True
_ = Right (^ 2) <*> Right 3  `is` Right 9
_ = Left "f"    <*> Right 3  `is` Left "f"
_ = Right (^ 2) <*> Left "x" `is` Left "x"
_ = Left "f"    <*> Left "x" `is` Left "f"

-- 1. pure id <*> xs = xs -- Identity
_ = \ x  -> pure id <*> Right x `is` Right id <*> Right x `is` Right x
_ = \ ex -> pure id <*> Left ex `is` Right id <*> Left ex `is` Left ex

-- 2. pure f <*> pure x = pure (f x) -- Homomorphism
-- 3. fs <*> pure x = pure ($ x) <*> fs -- Interchange
-- Эти законы доказываются точно так же, как и для Maybe, только с заменой
-- Just на Right. Рассмотрим только третий закон для случая, когда fs - Left ef.
_ = \ ef x -> Left ef <*> pure x `is` Left ef
_ = \ ef x -> pure ($ x) <*> Left ef `is` Left ef

-- 4. pure (.) <*> fs <*> gs <*> xs = fs <*> (gs <*> xs) -- Composition
-- Этот закон в случае, когда все fs, gs, xs - Right, доказывается, как в случае
-- с Maybe, только Just надо заменить на Right.
_ = \ ef eg ex -> pure (.) <*> Left ef <*> Left eg <*> Left ex `is`
                  Left ef <*> Left eg <*> Left ex `is` Left ef <*> Left ex `is`
                  Left ef

_ = \ ef eg ex -> Left ef <*> (Left eg <*> Left ex) `is` Left ef
-- Примерно так же в случае, когда что-то из fs, gs, xs - Right. Ясно, что
-- мы всегда вернем первый Left, и поскольку порядок аргументов в (<*>) слева
-- и справа одинаковый, это будет один и тот же Left.

--------------------------------------------------------------------------------
-- ПАРЫ КАК АППЛИКАКТИВНЫЕ ФУНКТОРЫ

-- В случае с парой будем работать чуть менее абстрактно, в качестве первого
-- элемента будем брать строки:
_ = pure True             `is` ("", True)
_ = ("f", (^ 2)) <*> ("x", 3) `is` ("fx", 9)

-- 1. pure id <*> xs = xs -- Identity
_ = \ x -> pure id <*> ("x", x) `is` ("", id) <*> ("x", x) `is` ("x", x)

-- 2. pure f <*> pure x = pure (f x) -- Homomorphism
_ = \ f x -> pure f <*> pure x `is` ("", f) <*> ("", x) `is` ("", f x)
_ = \ f x -> pure (f x) `is` ("", f x)

-- 3. fs <*> pure x = pure ($ x) <*> fs -- Interchange
_ = \ f x -> ("f", f) <*> pure x `is` ("f", f) <*> ("", x) `is` ("f", f x)
_ = \ f x -> pure ($ x) <*> ("f", f) `is` ("", ($ x)) <*> ("f", f) `is`
             ("f", f x)

-- 4. pure (.) <*> fs <*> gs <*> xs = fs <*> (gs <*> xs) -- Composition
_ = \ f g x -> pure (.) <*> ("f", f) <*> ("g", g) <*> ("x", x) `is`
               ("", (.)) <*> ("f", f) <*> ("g", g) <*> ("x", x) `is`
               ("f", (f . )) <*> ("g", g) <*> ("x", x) `is`
               ("fg", f . g) <*> ("x", x) `is` ("fgx", f (g x))

_ = \ f g x -> ("f", f) <*> (("g", g) <*> ("x", x)) `is`
               ("f", f) <*> ("gx", g x) `is` ("fgx", f (g x))

--------------------------------------------------------------------------------
-- ФУНКЦИИ КАК АППЛИКАКТИВНЫЕ ФУНКТОРЫ

-- В случае с парой будем работать чуть менее абстрактно, в качестве первого
-- элемента будем брать строки:
_ = pure True `is` const True
_ = ((+) <*> (* 2)) 3 `is` (\ x -> (+) x (x * 2)) 3 `is` (+) 3 6 `is` 9
-- Первый аргумент - функция двух аргументов, а второй - одного. В каждую
-- из функций подставляется аргумент лямбды, а второй аргумент первой функции -
-- это результат второй функции.

-- 1. pure id <*> xs = xs -- Identity
_ = \ f -> pure id <*> f `is` const id <*> f `is` (\ e -> const id e (f e)) `is`
           (\ e -> id (f e)) `is` (\ e -> f e) `is` f

-- 2. pure f <*> pure x = pure (f x) -- Homomorphism
_ = \ f x -> pure f <*> pure x `is` const f <*> const x `is`
               (\ e -> const f e (const x e)) `is` (\ _ -> f x) `is` const (f x)

_ = \ f x -> pure (f x) `is` const (f x)

-- 3. fs <*> pure x = pure ($ x) <*> fs -- Interchange
_ = \ f2 x -> f2 <*> pure x `is` f2 <*> const x `is`
              (\ e -> f2 e (const x e)) `is` (\ e -> f2 e x)

_ = \ f2 x -> pure ($ x) <*> f2 `is` const ($ x) <*> f2 `is`
              (\ e -> const ($ x) e (f2 e)) `is` (\e -> ($ x) (f2 e)) `is`
              (\ e -> f2 e x)

-- 4. pure (.) <*> fs <*> gs <*> xs = fs <*> (gs <*> xs) -- Composition
_ = \ f3 f2 f1 -> pure (.) <*> f3 <*> f2 <*> f1 `is`
                  const (.) <*> f3 <*> f2 <*> f1 `is`
                  (\ e -> const (.) e (f3 e)) <*> f2 <*> f1 `is`
                  (\ e -> (.) (f3 e)) <*> f2 <*> f1 `is`
                  (\ e' -> (\ e -> (.) (f3 e)) e' (f2 e')) <*> f1 `is`
                  (\ e' -> (.) (f3 e') (f2 e')) <*> f1 `is`
                  (\ e'' -> (\ e' -> (.) (f3 e') (f2 e')) e'' (f1 e'')) `is`
                  (\ e'' -> (.) (f3 e'') (f2 e'') (f1 e'')) `is`
                  (\ e'' -> f3 e'' (f2 e'' (f1 e'')))

_ = \ f3 f2 f1 -> f3 <*> (f2 <*> f1) `is` f3 <*> (\ e -> f2 e (f1 e)) `is`
                  (\ e' -> f3 e' ((\ e -> f2 e (f1 e)) e')) `is`
                  (\ e' -> f3 e' (f2 e' (f1 e')))

--------------------------------------------------------------------------------
-- СПИСКИ КАК АППЛИКАТИВНЫЕ ФУНКТОРЫ

-- Наконец, самое сложное - это аппликативный функтор из списка.
_ = pure True                     `is` [True]
_ = [(^2), (^3), (^4)] <*> [2, 3] `is` [4, 9, 8, 27, 16, 81]

-- 1. pure id <*> xs = xs -- Identity
_ = \ xs -> pure id <*> xs `is` [id] <*> xs `is` [f x | f <- [id], x <- xs] `is`
            [id x | x <- xs] `is` [x | x <- xs] `is` xs

-- 2. pure f <*> pure x = pure (f x) -- Homomorphism
_ = \ f x -> pure f <*> pure x `is` [f] <*> [x] `is`
             [f' x' | f' <- [f], x' <- [x]] `is` [f x]
_ = \ f x -> pure (f x) `is` [f x]

-- 3. fs <*> pure x = pure ($ x) <*> fs -- Interchange
_ = \ fs x -> fs <*> pure x `is` fs <*> [x] `is`
              [f x' | f <- fs, x' <- [x]] `is`
              [f x | f <- fs]
_ = \ fs x -> pure ($ x) <*> fs `is` [($ x)] <*> fs `is`
              [a f | a <- [($ x)], f <- fs] `is` [f x | f <- fs]

-- 4. pure (.) <*> fs <*> gs <*> xs = fs <*> (gs <*> xs) -- Composition
_ = \ fs gs xs -> pure (.) <*> fs <*> gs <*> xs `is`
                  [(.)] <*> fs <*> gs <*> xs `is`
                  [f . g | f <- fs, g <- fs] <*> xs `is`
                  [h x | h <- [f . g | f <- fs, g <- gs], x <- xs] `is`
                  [f (g x) | f <- fs, g <- gs, x <- xs]
_ = \ fs gs xs -> fs <*> (gs <*> xs) `is` fs <*> [g x | g <- gs, x <- xs] `is`
                  [f y | f <- fs, y <- [g x | g <- gs, x <- xs]] `is`
                  [f (g x) | f <- fs, g <- gs, x <- xs]

--------------------------------------------------------------------------------
-- ФУНКЦИЯ LIFTA2

-- Рассмотрим теперь функцию liftA2, определенную в классе типов Applicative.
-- Ее дефолтная реализация имеет следующий вид:
--liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
--liftA2 f xs ys = f <$> xs <*> ys

-- Посмотрим на примерах, во что это выливается для известных аппликативных
-- функторов.

_ = liftA2 (+) (Just 2) (Just 3) `is` Just 5
_ = liftA2 (+) Nothing  (Just 3) `is` Nothing
_ = liftA2 (+) (Just 2) Nothing  `is` Nothing
_ = liftA2 (+) Nothing  Nothing  `is` Nothing

_ = liftA2 (+) (Right 2)  (Right 3)  `is` Right 5
_ = liftA2 (+) (Left "x") (Right 3)  `is` Left "x"
_ = liftA2 (+) (Right 2)  (Left "y") `is` Left "y"
_ = liftA2 (+) (Left "x") (Left "y") `is` Left "x"

_ = liftA2 (+) ("x", 2) ("y", 3) `is` ("xy", 5)

_ = liftA2 (+) (^ 2) (^ 3) 2 `is` 12

_ = liftA2 (+) [3, 2, 1] [1, 2] `is` [4, 5, 3, 4, 2, 3]

-- Также теперь понятна дефолтная реализация (<*>) - liftA2 id. Действительно,
-- раньше мы делали буквально следующие.
_ = \ f2 x y -> liftA2 f2 (Just x) (Just y) `is` Just (f2 x y)
-- Аналогично и сейчас:
_ = liftA2 id (Just (^ 2)) (Just 3) `is` Just (id (^2) 3) `is` Just 9
-- Неудивительно, что это то же самое, что и (<*>).

-- Таким образом, liftA2 делает ровно то, что мы и хотели: достает аргументы из
-- контейнера, применяет к ним данную функцию и засовывает результат обратно
-- в контейнер. Причем структура итогового контейнера зависит от того, какой
-- были структуры контейнеров с аргументами. Это отличает функцию liftA2 идейно
-- от функции fmap, которая структуру не меняла.

-- Более того, liftA2 легко обобщается и на большее число аргументов:
liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
liftA3 f xs ys zs = f <$> xs <*> ys <*> zs

--------------------------------------------------------------------------------
-- УСЕЧЕННЫЙ СПРАВА ОПЕРАТОР АППЛИКАЦИИ

-- Осталось разобраться только с усеченными версиями оператора аппликации для
-- аппликативных функторов.

-- Для начала вспомним усеченные версии функции fmap, которые мы упоминали,
-- когда говорили об аппликативных функторах:
_ = [1, 2, 3] $> 4 `is` [4, 4, 4]
_ = 4 <$ [1, 2, 3] `is` [4, 4, 4]

-- Как видно, их смысл в сохранении структуру контейнера, но замене всех
-- значений в нем на переданный элемент. Действительно, то же самое и для
-- остальных функторов:
_ = Just 4     $> 1         `is` Just 1
_ = Nothing    $> 1         `is` Nothing
_ = Right id   $> flip      `is` Right flip
_ = Left False $> undefined `is` Left False
_ = (True, 2)  $> "True"    `is` (True, "True")
_ = (+ 4)      $> EQ        `is` const EQ

-- В отличие от усеченного fmap'а, усеченная аппликация меняет структуру
-- контейнера так, как будто бы дейтсвительно применялась аппликация, но
-- один из аргументов отбрасывается.

-- Рассмотрим дефолтную реализацию:
--(<*) :: f a -> f b -> f a
--(<*) = liftA2 const
-- Именно благодаря liftA2 структура контейнера меняется. Мы могли бы написать
-- просто const, и по типу бы все сходилось, но тогда мы просто игнорировали
-- второй контейнер, а здесь его структура влияет на результат. Но не значения!

-- Как она работает с Maybe:
_ = Just 4  <* Just "4" `is` Just 4  -- Ожидаемо.
_ = Nothing <* Nothing  `is` Nothing -- Ожидаемо.
_ = Nothing <* Just "4" `is` Nothing -- Ожидаемо.
_ = Just 4  <* Nothing  `is` Nothing -- Nothing повлиял на результат!
-- Обратите внимание, что значения могут быть даже другого типа, они все равно
-- будут проигнорированы.

-- Чуть сложнее выглядит на Either:
_ = Right 4  <* Right flip   `is` Right 4
_ = Left "x" <* Left "s"     `is` Left "x" -- В Left должен быть общий тип!
_ = Left ()  <* Right EQ     `is` Left ()
_ = Right 4  <* Left Nothing `is` Left Nothing

-- Интересный спецэфект проявляется с парами:
_ = ("x", 4) <* ("y", 6) `is` ("xy", 4) -- Структура меняется!

-- С функциями уже не так интересно, они не имеют никакой структуры.
_ = ((^ 2) <* (^ 3)) 3 `is` 9

-- Для списков изменение структуры - это изменение количества элементов. Мы
-- помним, что для аппликативного применения длины списков перемножаются; то же
-- происходит и здесь:
_ = [1, 2, 3] <* [4, 5] `is` [1, 1, 2, 2, 3, 3]
_ = [1, 2, 3] <* []     `is` []

--------------------------------------------------------------------------------
-- УСЕЧЕННЫЙ СЛЕВА ОПЕРАТОР АППЛИКАЦИИ

-- Наконец, в аппликативном функторе есть реализация усеченного оператора
-- аппликации в другую сторону: (*>). Как и следовало ожидать, он игнорирует
-- значения первого аргумента, но структура все равно влияет.

-- Мы не будем его подробно разбирать, потому что он работает симметрично,
-- но обсудим лишь, как его реализовать. Рассмотрим сразу 3 возможные версии.

tAp1 :: Applicative f => f a -> f b -> f b
tAp1 = flip const
-- Разумеется, такая версия работать не будет, поскольку в ней структура первого
-- аргумента не влияет:
_ = Just 4 <* Nothing `is` Nothing
_ = tAp1 Nothing (Just 4) `is` Just 4 -- Из симметрии нужен Nothing. Fail.

-- Куда более разумой кажется следующий вариант:
tAp2 :: Applicative f => f a -> f b -> f b
tAp2 = flip (<*) -- flip (liftA2 const)
-- Оказываетя, эта реализация тоже не подходит. Ошибка возникает на парах.
_ = tAp2 ("x", 4) ("y", 2) `is` ("yx", 2)
-- Получилось, что структура контейнеров влияет в неправильном порядке!

-- Значит, совсем правильный подход - совместить оба первых варианта в другом
-- порядке. Версия ниже уже работает:
tAp3 :: Applicative f => f a -> f b -> f b
tAp3 = liftA2 (flip const)

-- Но в библиотеке реализация все равно другая:
--(*>) :: Applicative f => f a -> f b -> f b
--as *> bs = id <$ as <*> bs

-- Как же так произошло? Разработчики библиотеки сделали наблюдение:
-- * liftA2 (flip const) xs ys =
-- = flip const <$> xs <*> ys =
-- = fmap (\ _ x -> x) xs <*> ys =
-- = | Получаем слева контейнер то же структуры, но из функций id! | =
-- = | Но по определению это просто (<$) из функтора. | =
-- = id <$ xs <*> ys, что и требовалось.

-- Смысл такой реализации в том, что (<$) (в отличие от ($>)) определен в классе
-- типов Functor, а не как свободная функция, поэтому функторы могут иметь
-- более эффективную реализацию (<$), чем его реализация по умолчанию:
-- fmap (const id) xs. Поэтому разумно использовать именно его.

--------------------------------------------------------------------------------
-- КЛАСС ТИПОВ ALTERNATIVE

-- Alternative - это моноид на аппликативных функторах. Соответственно, есть
-- нейтральный элемент и бинарная ассоциативная операция, по смыслу означающая
-- сложение.

class Applicative f => Alternative f where
    empty :: f a

    (<|>) :: f a -> f a -> f a
    infixl 3 <|>

--------------------------------------------------------------------------------
-- ЗАКОНЫ ДЛЯ ALTERNATIVE

-- Отличие Alternative от моноидов в их законах. Разумеется, должны быть
-- выполнены три закона для моноидов:
-- 1. mx <|> empty = mx
-- 2. empty <|> my = my
-- 3. (mx <|> my) <|> mz = mx <|> (my <|> mz)

-- Но кроме этого, для Alternative законы дистрибутивности:
-- 1. (f <|> g) <*> x = (f <*> x) <|> (g <*> x)
-- 2. empty <*> x = empty
-- 3. f <$> (x <|> y) = (f <$> x) <|> (g <$> x)
-- 4. f <$> empty = empty

-- Таким образом, (<$>) и (<*>) действительно выполняют роль умножения, и
-- получаетя, что (<|>) - сложение.

--------------------------------------------------------------------------------
-- MAYBE КАК ALTERNATIVE

-- Только два из известных нам аппликативных функторов можно обобщить до
-- Alternative: это список и Maybe. Начнем с более простого.

-- В случае Maybe мы помним, что реализаций моноидов несколько: например, можно
-- брать первый не Nothing, или последний не Nothing, или игнорирвать не
-- Nothing, а из оставшихся Just'ов извлекать элементы и объединять их (<>).
-- Было принято решение использовать просто первый Just.
instance Alternative Maybe where
    empty :: Maybe a
    empty = Nothing

    (<|>) :: Maybe a -> Maybe a -> Maybe a
    Nothing <|> my = my
    mx      <|> _  = mx

-- Осталось проверить выполнение всех законов. Для трех законов моноида
-- проверять ничего не требуется, потому что мы уже знаем, что Maybe с такой
-- же реализацией, только mempty и (<>), является моноидом. Проверим 4 закона
-- дистрибутивности.

-- 1. (f <|> g) <*> x = (f <*> x) <|> (g <*> x)
_ = \ mf mg -> (mf <|> mg) <*> Nothing `is` Nothing
_ = \ mf mg -> (mf <*> Nothing) <|> (mg <*> Nothing) `is`
               Nothing <|> Nothing `is` Nothing

_ = \ mg mx -> (Nothing <|> mg) <*> mx `is` mg <*> mx
_ = \ mg mx -> (Nothing <*> mx) <|> (mg <*> mx) `is`
               Nothing <|> (mg <*> mx) `is`
               mg <*> mx

_ = \ f mg x -> (Just f <|> mg) <*> (Just x) `is` Just f <*> Just x `is`
                Just (f x)
_ = \ f mg x -> (Just f <*> Just x) <|> (mg <*> Just x) `is`
                Just (f x) <|> (mg <*> Just x) `is` Just (f x)

-- 2. empty <*> x = empty
_ = \ mx -> empty <*> mx `is` Nothing <*> mx `is` Nothing
_ =         empty `is` Nothing

-- 3. f <$> (x <|> y) = (f <$> x) <|> (f <$> y)
_ = \ f mx -> f <$> (mx <|> Nothing) `is` f <$> mx
_ = \ f mx -> (f <$> mx) <|> (f <$> Nothing) `is` (f <$> mx) <|> Nothing `is`
              f <$> mx

_ = \ f my -> f <$> (Nothing <|> my) `is` f <$> my
_ = \ f my -> (f <$> Nothing) <|> (f <$> my) `is` Nothing <|> (f <$> my) `is`
              f <$> my

_ = \ f x y -> f <$> (Just x <|> Just y) `is` f <$> Just x `is` Just (f x)
_ = \ f x y -> (f <$> Just x) <|> (f <$> Just y) `is`
               Just (f x) <|> Just (f y) `is` Just (f x)

-- 4. f <$> empty = empty
_ = \ f -> f <$> empty `is` f <$> Nothing `is` Nothing
_ =        empty `is` Nothing

--------------------------------------------------------------------------------
-- СПИСОК КАК ALTERNATIVE

-- В случае списка Alternative работает так же, как и список-моноид.
instance Alternative [] where
    empty :: [a]
    empty = []

    (<|>) :: [a] -> [a] -> [a]
    (<|>) = (++)

-- Проверим теперь выполнение законов. Опять же, с законами для моноидов все
-- в порядке, нужно только убедиться в дистрибутивности.

-- 1. (f <|> g) <*> x = (f <*> x) <|> (g <*> x)
_ = \ fs gs xs -> (fs <|> gs) <*> xs `is` (fs ++ gs) <*> xs `is`
                  [ h x | h <- fs ++ gs, x <- xs ] `is`
                  [ f x | f <- fs, x <- xs] ++ [g x | g <- gs, x <- xs ]
_ = \ fs gs xs -> (fs <*> xs) <|> (gs <*> xs) `is`
                  [ f x | f <- fs, x <- xs] ++ [g x | g <- gs, x <- xs ]

-- 2. empty <*> x = empty
_ = \ xs -> empty <*> xs `is` [] <*> xs `is` []
_ =         empty `is` []

-- 3. f <$> (x <|> y) = (f <$> x) <|> (f <$> y)
_ = \ f xs ys -> f <$> (xs <|> ys) `is` f <$> (xs ++ ys) `is`
                 [f z | z <- xs ++ ys] `is` [f x | x <- xs] ++ [f y | y <- ys]
_ = \ f xs ys -> (f <$> xs) <|> (f <$> ys) `is` (f <$> xs) ++ (f <$> ys) `is`
                 [f x | x <- xs] ++ [f y | y <- ys]

-- 4. f <$> empty = empty
_ = \ f -> f <$> empty `is` f <$> [] `is` []
_ =        empty `is` []

--------------------------------------------------------------------------------
-- ФУНКЦИЯ ASUM

-- В прошлый раз мы изучали две функции, позволяющие для Foldable-контейнеров
-- сворачивать элементы, если их тип принадлежит классу типов Monoid. Конечно,
-- эту идею можно применить и для Alternative:
asum :: (Foldable t, Alternative f) => t (f a) -> f a -- Data.Foldable.
asum = foldr (<|>) empty

_ = asum [Nothing, Just 4, Just 2] `is` Just 4
_ = asum [Nothing, Nothing] `is` Nothing
_ = asum [] `is` Nothing

_ = asum [[1, 2], [3]] `is` [1, 2, 3]

--------------------------------------------------------------------------------
-- ФУНКЦИЯ SEQUENCEA_

-- Но что если мы хотим делать содержательные свертки контейнеров аппликативных
-- функторов, аккумулируя эффекты от каждого аппликативного функтора?

-- Если нас интересуют только эффекты, то можно просто отбрасывать значения.
-- Кроме того, мы не хотим требовать контекста моноида (то есть Alternative),
-- чтобы функция была более общей. Поэтому возьмем в качестве начального
-- элемента pure (). Какая будет сворчивающая функция? Ее тип должен быть
-- :: f a -> f () -> f (). Это же усеченный оператор аппликации!
sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
sequenceA_ = foldr (*>) (pure ())
-- То есть мы делаем свертку по контейнеру, которая на каждом шаге забывает
-- значения, но сохраняет и аккумулирует все эффекты.

-- Таким образом, мы заменили (<|>) на (*>), а empty на pure (), но получили
-- более мощную функцию, которая умеет аккумулировать эффекты от всех
-- аппликативных функторов, находящихся в контейнере.

-- В качестве Foldable используем список, а в качестве Applicative - тоже.
_ = sequenceA_ [[1, 2], [3], [4, 5, 6], [7, 8]] `is`
    [(), (), (), (), (), (), (), (), (), (), (), ()]
-- Эффект для списков - перемножение длин.

-- А для пар - аккумулирование первого элемента.
_ = sequenceA_ [("abc", 3), ("de", 2), ("fgh", 8)] `is` ("abcdefgh", ())

--------------------------------------------------------------------------------
-- ФУНКЦИЯ TRAVERSE_

-- Эта идея - заменить (<|>) на (*>), а empty на pure (), достаточно
-- универсальна для сверток. Действительно, у нас же еще была функция
-- foldMap :: (Foldable t, Monoid m) => (a -> m b) -> t a -> m b, реализованная
-- просто как foldr ((<>) . f) mempty.

-- Сначала перейдем к аппликативным функторам, оставив моноидальную структуру:
-- foldr ((<|>) . f) empty. Наконец, воспользуемся той же идеей, чтобы оставить
-- Applicative, но избавиться от моноидов. Получим функцию traverse_:
traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
traverse_ f = foldr ((*>) . f) (pure ())

_ = traverse_ (\ x -> [x, x ^ 2]) [2, 3, 4] `is`
    [(), (), (), (), (), (), (), ()]
-- Получили 8 значений, так как изначально список [[2, 4], [3, 9], [4, 16]],
-- откуда перемножением 2 * 2 * 2 = 8.

_ = traverse_ (\ x -> (show x, x)) [2, 5, 0, 4] `is` ("2504", ())
-- Здесь просто аккумулируем логи.

--------------------------------------------------------------------------------
-- ОГРАНИЧЕННОСТЬ FOLDABLE-ТИПОВ

-- К сожалению, рассмотренные выше версии не всегда удобны, ведь, скорее всего,
-- сами значения нам тоже понадобятся. Основная проблема в использовании
-- усеченных операторов аппликации. Если использовать полную версию, то
-- значение можно и оставить.

-- Осталось понять, как это сделать. Вероятно, мы не сможем удобным способом
-- вернуть один какой-то элемент. Но мы можем оставить исходный
-- Foldable-контейнер значений, а эффекты накопить аппликацией. Затем
-- значения можно извлечь и что-то с ними делать дальше.

-- Простой пример на списке:
_ = sequenceA' [("abc", 1), ("de", 2), ("fgh", 3)] `is` ("abcdedgh", [1, 2, 3])

-- Иными словами, нам нужна функция, которая умеет менять Foldable-контейнер и
-- Applicative-конейнер местами:
sequenceA' :: (Foldable t, Applicative f) => t (f a) -> f (t a)
sequenceA' = undefined

-- Аналогично можно рассмотреть и функцию traverse, которая обходит контейнер
-- элементов произвольного типа, превращая элементы в аппликативные функторы,
-- а значения аккумулирая в контейнере исходного вида:
traverse' :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f (t b)
traverse' = undefined

--------------------------------------------------------------------------------
-- КЛАСС ТИПОВ TRAVERSABLE

-- Существует класс типов Traversable, который объединяет в себе все
-- контейнеры, для которых можно реализовать указанные выше функции.

class (Functor t, Foldable t) => Traversable t where
    sequenceA :: Applicative f => t (f a) -> f (t a)
    sequenceA = traverse id

    traverse :: Applicative f => (a -> f b) -> t a -> f (t b)
    traverse f = sequenceA . fmap f

    -- Что-то еще...

    -- Как видно, обе эти функция реализуются друг через друга, таким образом,
    -- реализация может состоять только из одной из них. Оставшиеся две
    -- функции тоже имеют реализацию по умолчанию, но их мы разберем в следующий
    -- раз.

--------------------------------------------------------------------------------
-- MAYBE КАК TRAVERSABLE-КОНТЕЙНЕРЫ

instance Traversable Maybe where
    traverse :: Applicative f => (a -> f b) -> Maybe a -> f (Maybe b)
    traverse _ Nothing  = pure Nothing
    traverse f (Just x) = Just <$> f x
    -- Так как мы не знаем ничего об аппликативном функторе f, то единственный
    -- способ получить из воздуха значение - это f.

_ = traverse (\ x -> [x .. 2 * x]) (Just 2) `is` [Just 2, Just 3, Just 4]
_ = traverse (\ x -> [x .. 2 * x]) Nothing `is` [Nothing]

_ = sequenceA (Just [2, 3, 4]) `is` [Just 2, Just 3, Just 4]
_ = sequenceA Nothing `is` [Nothing]

--------------------------------------------------------------------------------
-- EITHER КАК TRAVERSABLE-КОНТЕЙНЕРЫ

-- Аналогично реализуется Traversable-инстанс для Either с фиксированным типом
-- для Left-конструктора:
instance Traversable (Either a) where
    traverse :: Applicative f => (b -> f c) -> Either a b -> f (Either a c)
    traverse _ (Left e)  = pure (Left e)
    traverse f (Right x) = Right <$> f x

_ = traverse (\ x -> [x .. 2 * x]) (Right 2) `is` [Right 2, Right 3, Right 4]
_ = traverse (\ x -> [x .. 2 * x]) (Left "") `is` [Left ""]

_ = sequenceA (Right [2, 3, 4]) `is` [Right 2, Right 3, Right 4]
_ = sequenceA (Left "") `is` [Left ""]

--------------------------------------------------------------------------------
-- ПАРЫ КАК TRAVERSABLE-КОНТЕЙНЕРЫ

instance Traversable ((,) a) where
    traverse :: Applicative f => (b -> f c) -> (a, b) -> f (a, c)
    traverse f (s, x) = (,) s <$> f x
    -- Извлекаем из аппликативного функтора значения, fmap на конструктор пары
    -- с заданным первым элементом, и упаковка обратно в тот же контейнер с
    -- сохранением структуры.

_ = traverse (\ x -> [x .. 2 * x]) ("s", 2) `is` [("s", 2), ("s", 3), ("s", 4)]

_ = sequenceA ("s", [2, 3, 4]) `is` [("s", 2), ("s", 3), ("s", 4)]

--------------------------------------------------------------------------------
-- СПИСКИ КАК TRAVERSABLE-КОНТЕЙНЕРЫ

instance Traversable [] where
    traverse :: Applicative f => (a -> f b) -> [a] -> f [b]
    traverse f = foldr (\ x ys -> liftA2 (:) (f x) ys) (pure [])

_ = traverse (\ x -> Just $ x ^ 2) [2, 3, 4] `is` Just [4, 9, 16]
_ = traverse (const Nothing) [2, 3, 4] `is` Nothing

_ = sequenceA [Just 2, Just 3, Just 4] `is` Just [2, 3, 4]
_ = sequenceA [Just 2, Nothing, Just 3] `is` Nothing
_ = sequenceA [] `is` Just []

--------------------------------------------------------------------------------
-- ТИПЫ IDENTITY И COMPOSE

-- Прежде чем знакомится с с законами для класса типов Traversable, нужно
-- познакомится с двумя вспомогательными конструкциями - типами Identity и
-- Compose.

-- Identity - это просто обертка, которая ничего не делает, она не добавляет
-- никаких эффектов.
newtype Identity a = Identity a deriving Show

instance Functor Identity where
    fmap f (Identity x) = Identity (f x)

instance Applicative Identity where
    pure x = Identity x
    Identity f <*> Identity x = Identity (f x)

-- Compose :: (* -> *) -> (* -> *) -> * оборачивает композицию на уровне типов.
newtype Compose f g a = Compose (f (g a)) deriving Show

instance (Functor f, Functor g) => Functor (Compose f g) where
    fmap f (Compose x) = Compose (fmap (fmap f) x)

instance (Applicative f, Applicative g) => Applicative (Compose f g) where
    pure x = Compose (pure (pure x))
    Compose f <*> Compose x = Compose ((<*>) <$> f <*> x)

-- Compose нужен, чтобы проносить, функции через несколько контейнеров:
_ = (+ 1) <$> (Compose [Just 4, Just 2]) `is` Compose [Just 5, Just 3]
_ = (+ 1) <$> (Compose [Just 4, Nothing]) `is` Compose [Just 5, Nothing]

_ = pure 4 `is` Compose [Just 4]

_ = Compose [Just (^ 2), Just (+ 1)] <*> Compose [Just 2, Just 3] `is`
    Compose [Just 4, Just 9, Just 3, Just 4]

_ = Compose [Just (^ 2), Nothing] <*> Compose [Just 2, Just 3] `is`
    Compose [Just 4, Just 9, Nothing, Nothing]

--------------------------------------------------------------------------------
-- ЗАКОНЫ ДЛЯ TRAVERSABLE: IDENTITY

-- Для Traversable сформулировано целых 6 законов, однако они распадаются на
-- два блока: три для traversable, три для sequenceA. Более того, они во
-- многом похожи на законы для функторов. Мы рассмотрим только два из них.

-- * traverse Identity = Identity -- (Закон Identity.)
-- Типы слева и справа - :: t a -> Identity (t a). Аналог в мире функторов -
-- fmap id = id, где типы слева и справа - :: t a -> ta. То есть отличие
-- исключенительно в оборачивании контейнера в аппликативную обертку Identity.

-- Доказывать формально не будем, воспользуемся методом "доказательство
-- примером" (никогда так не делайте):
_ = traverse Identity [2, 3] `is`
    foldr (\ x ays -> liftA2 (:) (pure x) ays) (pure []) [2, 3] `is`
    foldr (\ x ays -> liftA2 (:) (Identity x) ays) (pure []) [2, 3] `is`
    foldr (\ x (Identity ys) -> Identity (x : ys)) (pure []) [2, 3] `is`

    (\ (Identity ys) -> Identity (2 : ys))
        (foldr (\ x (Identity ys) -> Identity (x : ys)) (pure []) [3]) `is`

    (\ (Identity ys) -> Identity (2 : ys))
        ((\ (Identity ys) -> Identity (3 : ys))
            (foldr (\ x (Identity ys) -> Identity (x : ys)) (pure []) [])) `is`

    (\ (Identity ys) -> Identity (2 : ys))
        ((\ (Identity ys) -> Identity (3 : ys)) (pure [])) `is`

    (\ (Identity ys) -> Identity (2 : ys))
        ((\ (Identity ys) -> Identity (3 : ys)) (Identity [])) `is`

    (\ (Identity ys) -> Identity (2 : ys)) (Identity [3]) `is`

    Identity [2, 3]

--------------------------------------------------------------------------------
-- ЗАКОНЫ ДЛЯ TRAVERSABLE: COMPOSITION

-- * traverse (Compose . fmap g2 . g1) =
-- = Compose . fmap (traverse g2) . traverse g1 -- (Закон Composition.)

-- Аналог в мире функторов

-- Закон можно переписать в более привычном виде:
-- * traverse (\ x -> Compose (fmap g2 (g1 x))) xs =
-- = Compose (fmap (traverse g2) (traverse g1 xs))

-- Теперь разберемся с типами:
-- xs             :: Traversable t => t a
-- g1             :: Applicative f1 => a -> f1 b
-- g2             :: Applicative f2 => b -> f2 c
-- traverse g1 xs :: Applicative f1 => f1 (t b)
-- traverse g2    :: Applicative f2 => t b -> f2 (t c)

-- Отсюда ясно, откуда у нас берется fmap и почему g2 и g1 в обратном порядке:
-- надо начала протащить g1 простым траверсом, а потом уже g2 придется
-- протащить сквозь апплтикативный функтор f1 с помощью fmap'а.

-- "Докажем" этот закон примером:

_ = traverse (\ x -> Compose (fmap Right (Just x))) [2, 3] `is`
    traverse (\ x -> Compose (Just (Right x))) [2, 3] `is`
    Compose (Just (Right [2, 3]))

_ = Compose (fmap (traverse Right) (traverse Just [2, 3])) `is`
    Compose (fmap (traverse Right) (Just [2, 3])) `is`
    Compose (Just (traverse Right [2, 3])) `is`
    Compose (Just (Right [2, 3]))

--------------------------------------------------------------------------------
-- ДРУГИЕ ЗАКОНЫ ДЛЯ TRAVERSABLE

-- Третий закон для Traversable (он называется Naturality) в системе типов
-- Haskell автоматически выполняется всегда, поэтому его рассматривать не будем.

-- Наконец, три закона для sequenceA формулируются аналогично трем законам для
-- traverse, только traverse f выражен через sequenceA, поэтому их тоже
-- проигнорируем.

-- В чем смысл этих законов:
-- 1. Каждый элемент контейнера обходится однократно.

-- 2. Тривиальность функции pure (если обойти контейнер функцией pure, получим
--    pure от контейнера.
_ = traverse pure [2, 3, 5] `is` Just [2, 3, 5]

-- 3. Структура Traversable-контейнера не меняется, но структура внешнего
--    аппликативного функтора может быть любой; она зависит от элементов
--    исходного контейнера, то есть контейнер может, например, полностью
--    пропасть.
_ = traverse (\ x -> Right (x ^ 2)) [2, 3, 5] `is` Right [4, 9, 25]
_ = traverse (\ x -> if odd x then Left "" else Right x) [2, 3, 5] `is` Left ""
