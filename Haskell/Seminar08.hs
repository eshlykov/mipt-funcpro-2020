{-# LANGUAGE InstanceSigs #-}
{-# OPTIONS_GHC -Wno-empty-enumerations #-}
{-# OPTIONS_GHC -Wno-missing-fields #-}

module Seminar08 where

import Prelude hiding (
        ($!), last, iterate, cycle, take, dropWhile, scanr,
        Semigroup, (<>),
        Monoid, mempty, mconcat,
        Foldable, foldMap, foldr, length, elem
    )

-- Соглашение на сегодня:
-- * если мы переопределяем свободную функцию из библиотеки, то реализуем ее под
--   тем же именем;
-- * если мы переопределяем функцию из библиотеки, определенную в классе типов,
--   в рамках нашего класса типа, то реализуем ее под тем же именем;
-- * если мы определяем свободную функцию, в библиотеке реализованную в рамках
--   класса типа, то начинаем ее имя с `_` для обычных имен и с `@` для
--   операторов.

--------------------------------------------------------------------------------
-- ЛЕНИВАЯ СТРАТЕГИЯ ВЫЧИСЛЕНИЙ

-- Как говорилось в прошлый раз, в Haskell принята ленивая стратегия вычислений,
-- то есть при вычислении в модели подстановки сначала происходит подстановка
-- аргументов в тело функции, а затем вычисление самих аргументов.

-- В чистых функциональных языках выполняется свойство, что результат вычисления
-- программы не зависит от выбранной стратегии вычислений. Она может быть как
-- ленивой, так энергичной, так и любой другой. Речь идет о программах,
-- которые завершаются без ошибок.

-- В императивных языках это в общем случае не выполнено, так как вычисления
-- содержат изменяемые переменные (таким образом, модель подстановки, строго
-- говоря, неприменима).

-- Полезные свойства ленивой модели: если аргумент функции не используется, то
-- его вычисление не происходит. Из-за этого выигрваем как на условных
-- выряжениях, где одна из ветвей обязательно игнорируется, так и на логических
-- операторах.

-- Однако в случае, когда параметр используется несколько раз, он, казалось бы,
-- и вычисляется несколько раз. К счастью, придумали механизм разделения,
-- позволяющий сводить повторные вычисления на нет: вместо передачи выражения
-- в функцию передается указатель на область памяти, где хранится это
-- отложенное выражение (thunk). При первом обращении оно вычисляется, а при
-- повторном просто достается. По сути, можно думать об этом как о кешировании.

-- (За скобками: однако из-за такой оптимизации, вообще говоря, нельзя
-- использовать модель подстановки. Но мы это проигнорируем.)

-- Еще одно преимущество ленивой модели касается расходимости. Так как
-- значения необязательно вычисляются, в них можно передать выражения,
-- вычисления которых завершаются ошибкой.

-- Если в функцию возможно передать аргумент, вычисление которого завершается
-- ошибкой, а сама функция при этом успешно сходится к значению, то такую
-- функцию называют нестрогой. Примеры нестрогих функий: fst, snd.

-- Для строгих функций, наоборот, при передаче в качестве аргумента
-- расходящегося выражения значение функции расходится.

-- Строгость и нестрогость может определяться не для функции целиком, а для
-- проекции функции на аргументы. Например, можно сказать, что какая-то функция
-- строгая по первому аргументу, но не строгая по второму (const, (||), (&&)).

-- В компиляторе Haskell есть встроенный анализатор строгости. Если функция
-- оказалась строгой, то тогда ее вычисление допустимо провести в энергичной
-- модели, что может улучшить производительность.

--------------------------------------------------------------------------------
-- СЛАБАЯ ГОЛОВНАЯ НОРМАЛЬНАЯ ФОРМА

-- Назовем редексом (redex, от reducible expression) выражение, которое может
-- быть непосредственно вычислено.

-- Для интересующихся: в терминах лямбда-исчисления редекс - это лямбда-терм
-- следующего вида: (λx.M)N. На самом деле, правда, в лямбда-исчислении
-- существуют и другие виды редексов, но они нас пока не интересуют.

-- Выражения, которые не содержат редексов, находятся в нормальной форме, то
-- есть оно доведены до окончательного результата, и внутри никаких вычислений
-- произвести уже нельзя.

-- Примеры выражений в нормальной форме:
-- "18042020"
-- (18, 4, 2020)
-- \ _ -> "18042020"

-- Примеры выражений не в нормальной форме:
-- "18" ++ "04" ++ "2020"
-- (,,) 18 4 2020
-- (\ _ -> "18042020") undefined

-- В Haskell существует промежуточная концепция: слабая головная нормальная
-- форма (weak head normal form, WHNF). Это выражения следующих видов:
-- * любая лямбда-абстракция;
-- * конструктор данных, в том числе примененный частично;
-- * частично примененная встроенная функция.

-- Примеры:
-- \ _ -> "18" ++ "04" ++ "2020"
-- (,,) 18 4
-- (+) 2020

-- Все выражения, находящие в нормальной форме, также находятся в слабой
-- головной нормальной форме. Во многих случая вычислений выражений
-- останавливается при достижении ими WHNF.

--------------------------------------------------------------------------------
-- ФОРСИРОВАНИЕ ВЫЧИСЛЕНИЙ

-- При вычислениях в ленивой модели может возникать проблема, что отложенные
-- вычисления становятся слишком громоздкими. Например, такое обычно возникает
-- при обходе списков с аккумулятором. Чтобы этого избежать, в Haskell есть
-- специальная функция seq, которая форсирует вычисления, нарушая тем самым
-- принятую ленивую семантику.

-- Функцию seq нельзя определить в языке напрямую, но она почти эквивелнтна
-- следующей функции:
-- seq :: a -> b -> b
-- seq ⊥ _ = ⊥
-- seq _ b = b
-- То есть если первый аргумент расходится, то и seq расходится, а если нет, то
-- он игнорируется и возвращается второй аргумент.

-- Таким образом, seq запускает вычисление первого аргумента, но возвращает
-- значение второго аргумента. Однако вычисление первого аргумента происходит
-- только до головной нормальной формы, таким образом, fiveValid = 5, а при
-- вычислении fiveInvalid () произойдет ошибка:
fiveValid   = [undefined] `seq` 5
fiveInvalid = undefined `seq` 5

--------------------------------------------------------------------------------
-- СТРОГИЙ ОПЕРАТОР ПРИМЕНЕНИЯ

-- Сама функция seq не очень удобна, поэтому в Prelude существует оператор
-- ($!), определенный следующим образом:
($!) :: (a -> b) -> a -> b -- (Prelude.$!)
f $! x = x `seq` f x
infixr 0 $!

-- Тогда запись f $! x читается как "довести вычисление x до WHNF и вычислить на
-- нем функцию f".

-- Применим этот оператор для написания более эффективной версии факториала:
factorial :: Integer -> Integer
factorial n | n >= 0    = helper 1 n
            | otherwise = error "`factorial n` requires `n >= 0`"
    where
        helper acc 0 = acc
        helper acc n = (helper $! (acc * n)) (n - 1)

-- На самом деле в таком простом случае, скорее всего, компилятор сам додумается
-- до энергичной стратегии вычислений, но если мы не уверены или просто хотим
-- его поддержать, то можно использовать ($!).

--------------------------------------------------------------------------------
-- НЕОПРОВЕРЖИМЫЙ ОБРАЗЕЦ

-- Сейчас нам уже известно два образца, с которыми сопоставление всегда
-- происходит успешно: это `_` (wildcard pattern) и идентификатор (as pattern).
-- Существует третий вид: неопровержимый образец (irrefutable pattern).

-- Синтаксис для неопровержимого образца следующий: ~<pattern>. Таким образом,
-- это то же самое, что и обычный образец, перед которым добавили символ
-- тильды `~` (внутренний образец при необходимости нужно заключить в скобки).

-- В стандарте языка словом неопровержимый образец называются только описанный
-- выше паттерн, однако иногда все три вида образцом, с которыми не может
-- не произойти сопоставления, называют неопровержимыми. Мы и сами так делали
-- в прошлых семинарах. Сам неопровержимый образец с `~` при этом называют
-- ленивым из-за его особенности.

-- Дело в том, что сопоставление с образцом <pattern> происходит не в момент
-- сопоставление с образцом в функции, лямбда-абстракции или выражении case..of,
-- а в момент использования этого значения. И если при этом сопоставление
-- произошло неудачно, то произойдет ошибка.

-- Ленивые образцы могут использоваться для уменьшения строгости функций при
-- реализации сопоставления с образцом (которое, как известно, вносит
-- энергичность, потому что обычно необходимо вычислить аргумент по крайней мере
-- до WHNF).

-- Рассмотрим пример:
updatePair :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
updatePair f g ~(x, y) = (f x, g y)

-- Оказывается, эта функция лучше работает в случае, если функции f и g
-- не используют свои аргументы: в таких ситуациях в качестве пары может быть
-- передано вычисление, завершающееся ошибкой, например:
fourtyTwo = updatePair (const 4) (const 2) undefined

-- Если бы написали обычный образец - конструктор пары, то тогда для
-- применения функции пришлось бы вычислить пары до WHNF, то есть мы вылетели
-- бы с ошибкой. Тем не менее, значение функции от этого, казалось бы, вообще
-- не зависит, поэтому такое повередение не очень разумно (с этим утверждением
-- можно поспорить, но в некотором смысле оно логично).

-- Если бы у нас не было неопровержимых образцов, то все-таки можно было бы
-- реализовать эквивалентную версию, но это бы выглядело более громоздко:
updatePairNoPm :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
updatePairNoPm f g p = (f $ fst p, g $ snd p)

--------------------------------------------------------------------------------
-- ФЛАГИ СТРОГОСТИ

-- Тем не менее, у нас остается проблема, что значения, передаваемые в
-- конструкторы данных, не вычисляются, так как применение конструктора данных
-- по определению находится в WHNF.

-- В Haskell существует механизм, благодаря которому можно в объявлении типа
-- указать, что данное поле необходимо вычислять (до WHNF, конечно) всегда при
-- конструкировании объекта или сопоставлении с образцом: для этого надо
-- перед типом поля поставить флаг строгости `!`.
data DoubleBox d = DoubleBox { cellLazy :: d, cellStrict :: !d } deriving Show

emptyTuple     = cellStrict $ DoubleBox undefined ()
errorUndefined = cellLazy $ DoubleBox () undefined

-- В примере выше флаг ставится перед переменной типа в переменном типе данных
-- с метками полей. Но оно работает и перед обычными типами в типах без меток
-- полей.

-- Аналогичное поведение и во время сопоставления с образцом.

-- Важно, что вычисление полей с флагами строгости происходит, но  все равно
-- только до WHNF, то есть такая запись уже будет работать:
emptyList = cellLazy $ DoubleBox [] [undefined]

-- Обратите внимание, если у поля стоит метка строгости, компилятор не даст вам
-- оставить поле без инициализации.

--------------------------------------------------------------------------------
-- БЕСКОНЕЧНЫЕ СПИСКИ

-- Выбранная ленивая стратегия языка позволяет стразу же из коробки поддерживать
-- бесконечные структуры данных, например, списки:
ns = 0 : map (+ 1) ns

-- Дело в том, что при объявлении конструктора `:` списка перед типом-аргументом
-- нет флага строгости, поэтому объявление ns выше находится в WHNF, и его
-- вычисление пока что считается завершенным:
--data [] a = [] | a : [a] -- Вывод `:i []`.

-- Не все функции для работы со списками будут работать корректно с бесконечными
-- списками, например, last:
last :: [a] -> a -- Prelude.last
last [x]      = x
last (_ : xs) = last xs
last _        = errorWithoutStackTrace "Seminar08.last: empty list"

-- Для справки: errorWithoutStackTrace :: String -> a работает, как и обычный
-- error, но не выводит stack trace, как следует из названия. Именно ее обычно
-- используют в реализации библиотечных функций.

-- Большая часть функций при применении к бесконечным спискам получает просто
-- другой бесконечный список.

-- Есть функции, которые заточены для работы с бесконечными списками, например,
-- генерация бесконечных списков:
iterate :: (a -> a) -> a -> [a] -- Prelude.iterate
iterate f x = x : iterate f (f x)

repeat :: a -> [a] -- Prelude.repeat
repeat x = iterate id x

cycle :: [a] -> [a] -- Prelude.cycle
cycle [] = errorWithoutStackTrace "Seminar08.cycle: empty list"
cycle xs = xs ++ cycle xs

-- Как правило, сами бесконечные списки не нужны, мы же все равно не сможем
-- достать оттуда все элементы. Нужны функции, которые позволяют достать
-- конечную часть списка. Такие функции в библиотеке имеются, вот некоторые
-- из них:
take :: Int -> [a] -> [a] -- Prelude.take
take _ []                   = []
take n (x : xs) | n > 0     = x : take (n - 1) xs
                | otherwise = []

dropWhile :: (a -> Bool) -> [a] -> [a] -- Prelude.dropWhile
dropWhile _ []                   = []
dropWhile p (x : xs) | p x       = dropWhile p xs
                     | otherwise = xs

-- Аналогично есть drop и takeWhile.

--------------------------------------------------------------------------------
-- АРИФМЕТИЧЕСКИЕ ПОСЛЕДОВАТЕЛЬНОСТИ

-- В Haskell есть специальный синтаксис для генерации последовательностей от
-- некоторого начального значения, возможно, с указанием шага, возможно, с
-- указанием верхней границы.

-- Список чисел от 1 до 11 включительно:
numsTo11 = [1 .. 11] :: [Integer]

-- Верхняя граница необязательна: если ее нет, генерируется бесконечный список.
nats = [1 .. ] :: [Integer]

-- Шаг задается через указание второго элемента списка:
oddsTo11   = [1, 3 .. 11] :: [Integer]
oddsFrom11 = [11, 9 .. 1] :: [Integer] -- Шаг может быть отрицательным.

-- Шаг работает и в случае, если границу не указывать.
odds         = [1, 3 .. ] :: [Integer]
oddsNegative = [-1, -3 .. ] :: [Integer]

-- Все разобранные арифметические последовательные работают не только с
-- числами, но и вообще с любыми типами из класса типов Enum. Более того,
-- перечисленные конструкции - синтаксический сахар для функций из класса типов
-- Enum, которые мы не рассмотрели в прошлый раз:
--enumFromTo     :: Enum a => a -> a -> [a]
--enumFromThenTo :: Enum a => a -> a -> a -> [a]
--enumFrom       :: Enum a => a -> [a]
--enumFromThen   :: Enum a => a -> a -> [a]

-- Таким образом, можно с помощью арифметических последовательностей
-- генерировать строки (списки символов), последовательности из Bool, Ordeding,
-- Float и Double и даже пустых кортежей.

-- Разберем для полноты некоторые крайние случаи:
empty1 = [10 .. 1]   -- Без шага - по умолчанию 1, значит, пустой список.
two    = [2, 4 .. 3] -- Второй элемент не влезает => он отбасывается.
twos   = [2, 2 .. 3] -- Второй элемент равен первому => бесконечный список.
twos1  = [2, 2 .. ]  -- То же самое.
empty2 = [2, 2 .. 1] -- Но тут пустой список!
bools  = [False .. ] -- Bounded-тип => список все-таки конечен.

--------------------------------------------------------------------------------
-- LIST COMPREHENSION

-- Арифметические последовательности позволяют генерировать сравнительно простые
-- по стуктуре списки. Для выделения более сложных списков служит list
-- comprehension.

-- Синтаксис следующий: [ e | q1, ..., qN ], где e - произвольное выражение, а
-- каждое qK-е имеет одну из следующих форм:
-- * генератор `p <- l`, p - паттерн из сопоставления с образцом, l - список;
-- * локальное связывание `let`;
-- * гард `cond` - выражение типа Bool.

-- Эта возможность много всего позволяет, а синтаксис весьма сложен, поэтому
-- рассмотрение всех тонкостей займет много времени. Возьмем лишь простейший
-- пример пифагоровых троек:
pifs = [(x, y, z) | x <- [1 .. 100], y <- [x .. 100], z <- [1 .. 100],
                    x ^ 2 + y ^ 2 == z ^ 2 ]

-- В случае, если сопоставление с образцом в генераторе p <- l прошло неуспешно,
-- текущий элемент отбрасывается.

-- Аналогично, если гард оказался равен False.

-- Списки итерируются слева направа: сначала фиксируется элемент первого списка,
-- затем для него перебираются элементы оставшихся списков, затем переход ко
-- второму элементу первого списка и так далее.

--------------------------------------------------------------------------------
-- ПРАВАЯ СВЕРТКА

-- Рассмотрим теперь, как ленивость языка влияет на свертки списков. Правая
-- свертка устроена очень простым образом: если список xs имеет вид
-- x1  :  x2  :  ...  :  xN  :  [], то выражение foldr f y xs равно
-- x1 `f` x2 `f` ... `f` xN `f` y, где `f` имеет правую ассоциативность:
-- infixr `f` (кстати, приоритет указывать необязательно, тогда берется 9).

_foldr :: (a -> b -> b) -> b -> [a] -> b -- Не совсем Prelude.foldr
_foldr _ y []       = y
_foldr f y (x : xs) = f x (_foldr f y xs)
-- В реализации использовали foldr, которую мы перереализуем для непустых
-- списков.

-- Ленивая семантика языка позволяет правой свертке работать на бесконечных
-- списках, если второй элемент сворачивающей функции не используется. Например,
zero = _foldr const 3 [0 .. ]

--------------------------------------------------------------------------------
-- ЛЕВАЯ СВЕРТКА

-- Левая свертка работает симметрично правой: в начало подставляется
-- инициализирующее значение, а затем согласно левой ассоциативности
-- функция применяется к элемента списка слева направо, то есть если xs - это
-- x1  :  ...  :  xN  :  [], то выражение foldl f y xs равно
-- y  `f` x1 `f` ... `f` xN, где infixl `f`.

_foldl :: (b -> a -> b) -> b -> [a] -> b -- Не совсем Prelude.foldl
_foldl _ y []       = y
_foldl f y (x : xs) = _foldl f (f y x) xs

-- К сожалению, здесь ленивость языка нас подводит, поскольку начальное
-- значение аккумулируется, но не вычисляется на каждом шаге. Поэтому левая
-- свертка в таком виде не рекомендуется к использованию.

--------------------------------------------------------------------------------
-- СТРОГИЕ СВЕРТКИ

-- Чтобы сделать левую свертку эффективной, нужно форсировать вычисление нового
-- начального значения, для чего можно использовать оператор ($!):
_foldl' :: (b -> a -> b) -> b -> [a] -> b -- Не совсем Data.List.foldl'
_foldl' _ y []       = y
_foldl' f y (x : xs) = (_foldl' f $! f y x) xs

-- Она не содержит никаких недостатков по сравнению с обычной версией левой
-- свертки, а потому всегда рекомендуется к использованию там, где нужна левая
-- свертка. Но ее нет в Prelude, поэтому необходим дополнительный импорт.

-- Обратите внимание, что левые сверкти реализованы через хвостовую рекурсию,
-- поэтому каждый вызов разворачивается в новый вызов левой свертки. Несмотря на
-- эффективность этого подхода, это означает, что левая свертка не работает для
-- бесконечных списков.

-- Для симметричности существует строгая версия правой свертки:
_foldr' :: (a -> b -> b) -> b -> [a] -> b -- Не совсем Data.Foldable.foldl'
_foldr' _ y []       = y
_foldr' f y (x : xs) = f x $! (_foldr f y xs)

--------------------------------------------------------------------------------
-- СВЕРТКИ БЕЗ НАЧАЛЬНОГО ЗНАЧЕНИЯ

-- Иногда сложно написать свертку таким образом, чтобы корректно вернуть
-- начальное значение на пустом списке. Например, свертка в списка в
-- максимальное или минимальное значение. Для таких целей служат функции,
-- которые на пустом списке бросают ошибку, а на непустом вызывают обычную
-- свертку, в которой вместо начального значения подставлен первый элемент.

_foldr1 :: (a -> a -> a) -> [a] -> a -- Не совсем Prelude.foldr1
_foldr1 _ []       = errorWithoutStackTrace "Seminar08._foldr1: empty list"
_foldr1 f (x : xs) = _foldr f x xs

_foldl1' :: (a -> a -> a) -> [a] -> a -- Не совсем Data.List.foldl1'
_foldl1' _ []       = errorWithoutStackTrace "Seminar08._foldl1': empty list"
_foldl1' f (x : xs) = _foldl' f x xs

-- Есть также версия нестрогой левой свертки.
_foldl1 :: (a -> a -> a) -> [a] -> a -- Не совсем Prelude.foldl1
_foldl1 _ []       = errorWithoutStackTrace "Seminar08._foldl1': empty list"
_foldl1 f (x : xs) = _foldl f x xs

-- Здесь есть важное отличие: теперь результат свертки по типу должен совпадать
-- с элементом списка. Действительно, на списке из одного элемента результат - и
-- есть единственный элемент списка.

--------------------------------------------------------------------------------
-- СКАНИРОВАНИЕ

-- Функции сканирования позволяют получить все промежуточные результаты свертки
-- исходного списка в виде нового списка.

scanl' :: (b -> a -> b) -> b -> [a] -> [b] -- Data.List.scanl'
scanl' _ y []       = [y]
scanl' f y (x : xs) = y : (scanl' f $! f y x) xs

scanr :: (a -> b -> b) -> b -> [a] -> [b] -- Prelude.scanr
scanr _ y []       = [y]
scanr f y (x : xs) = (f x z) : zs
    where zs @ (z : _) = scanr f y xs

-- В отличие от левой свертки, левое сканирование хорошо работает с бесконечными
-- списками, поскольку просто получает бесконечный список на выходе, а от него
-- можно легко взять нужную часть.

-- Правое сканирование на бесконечных списках работает, как и раньше: в случае,
-- если функция игнорирует свой второй аргумент.

-- Есть сканирование, реализованное для нестрогой левой свертки, а также
-- сканирования без начального значения:
-- * Prelude.scanl;
-- * Prelude.scanl1;
-- * Prelude.scanr1.

--------------------------------------------------------------------------------
-- РАЗВЕРТКИ

-- Разветка позволяет по функции и начальному значению развернуть результаты
-- функции в список. Разветки нет в Prelude, но она есть в модуле Data.List,
-- причем только правая.
unfoldr :: (b -> Maybe (a, b)) -> b -> [a] -- Data.List.unfoldr
unfoldr f y = maybe [] go (f y)
    where go (x, z) = x : unfoldr f z

-- С помощью функции unfoldr можно генерировать конечные списки. Если мы хотим
-- гененировать бесконечные, то можно вспомпить о функции iterate.

--------------------------------------------------------------------------------
-- ПОЛУГРУППЫ

-- Когда мы рассматривали свертки, мы представляли сворачивающую функцию
-- как операцию, которая может быть либо правоассоциативной, либо
-- левоассоциативной.

-- Оказывается, дли многих типов данных можно определить простую естественную
-- операцию, которая будет ассоциативной, то есть работать одинаково справа
-- налево и слева направо.

-- В математике множества с бинарной ассоциативной операцией над ним называют
-- полугруппами.

-- В случае языка Haskell множества - это типы, а операции - функции. Мы уже
-- знаем способ, как определять на типах операции: с помощью классов типов.

-- Соотвественно, можно объявить класс типов Semigroup c ассоциативной бинарной
-- операцией (<>).

class Semigroup a where -- Prelude.Semigroup
    (<>) :: a -> a -> a

-- Для корректных экземпляров этого класса должен выполняться закон
-- ассоцивтиности:
-- x <> (y <> z) = (x <> y) <> z.

--------------------------------------------------------------------------------
-- СТАНДАРТНЫЕ ПОЛУГРУППЫ

-- Реализуем экземпляры полугрупп для известных типов.

instance (Semigroup a, Semigroup b) => Semigroup (a, b) where
    (x1, y1) <> (x2, y2) = (x1 <> x2, y1 <> y2)
    -- То же самое для кортежей больших размерностей.

instance Semigroup [a] where
    (<>) = (++)

instance Semigroup b => Semigroup (a -> b) where
    (f <> g) x = f x <> g x

instance Semigroup a => Semigroup (Maybe a) where
    Just x <> Just y = Just $ x <> y
    x      <> y      = maybe y (const x) x

instance Semigroup b => Semigroup (Either a b) where
    Right x <> Right y = Right $ x <> y
    x       <> y       = either (const x) (const y) y

instance Semigroup () where
    _ <> _ = ()

instance Semigroup Ordering where
    LT <> _ = LT
    GT <> _ = GT
    EQ <> x = x

-- Полугруппы имеют полезное свойство: из-за  ассоциативности операции порядок
-- применения операций не имеет значения, таким образом, компилятор может
-- распараллеливать цепочки этих вычислений, что делеает те же самые свертки
-- эффективнее.

-- Но у полугрупп есть недостаток: непонятно, как выполнять свертку на пустых
-- списках. Поэтому по сути доступны только версии сверток без начального
-- значения: foldr1 и foldl1'.

--------------------------------------------------------------------------------
-- МОНОИДЫ

-- Моноиды расширяют понятие полугруппы, добавляя во множество нейтральный
-- элемент.

class Semigroup a => Monoid a where -- Prelude.Monoid
    mempty :: a

    mappend :: a -> a -> a
    mappend = (<>)

    mconcat :: [a] -> a
    mconcat = _foldr (<>) mempty

-- Для моноидов требуется выполнение двух дополнительных законов:
-- * mempty <> x = x
-- * x <> mempty = x

-- Пояснение к функции mappend: раньше моноиды и полугруппы были не связанными
-- классами типов, полугруппы даже не входили в Prelude, и у моноидов для
-- операции был только mappend. В новых версиях компилятора сделали так,
-- что моноиды расширяют полугруппу, полугруппы добавили в Prelude, и теперь
-- у mappend есть логичная реализация по умолчанию - (<>) из полугрупп.

--------------------------------------------------------------------------------
-- СТАНДАРТНЫЕ МОНОИДЫ

-- Определим инстансы для моноидов среди известных типов.

instance (Monoid a, Monoid b) => Monoid (a, b) where mempty = (mempty, mempty)
-- Аналогично для больших размерностей.

instance Monoid [a] where mempty = []

instance Monoid b => Monoid (a -> b) where mempty _ = mempty

instance Monoid a => Monoid (Maybe a) where mempty = Nothing

instance Monoid () where mempty = ()

instance Monoid Ordering where mempty = EQ

-- Если мы снова говорим о свертках, то если тип является моноидом, то элемент
-- mempty можно брать как начальное значение свертки. Таким образом, становится
-- возможным использование сверток на пустых списках.

--------------------------------------------------------------------------------
-- МОНОИД FIRST

-- Оказывается, для некоторых типов возможно определить операцию и нейтральный
-- элемент, чтобы тип был моноидом, несколькими способами.

-- Так, для Maybe также существует и второй моноид, который возвращает всегда
-- первый Just, если он есть. Его отличие в том, что он не требует, чтобы
-- тип - параметр Maybe был моноидом.

-- Так как инстантс моноида для Maybe уже объявлен, нужно использовать обертку.
-- Ее каноническое название - First.
newtype First a = First { getFirst :: Maybe a }

instance Semigroup (First a) where
    First x <> First y = First $ maybe y (const x) x
instance Monoid (First a) where mempty = First Nothing

-- Замечание: чтобы объявить тип моноидом, нужно не забыть объявить его и
-- полугруппой, так как моноиды расширяют полугруппу. В противном случае будет
-- ошибка, что нет инстанса для типа Semigroup (First a) (в нашем случае), то
-- есть просто нарушение контекста, нужного для реализации инстанса
-- Monoid (First a).

--------------------------------------------------------------------------------
-- ФУНКЦИИ FOLD И FOLDMAP

-- Как мы уже говорили, если типы являются моноидами, то списки значений можно
-- сворачивать с помощью операции (<>). Функция, которая это делает, называется
-- просто fold. Никакой буквы не стоит, поскольку операция ассоциативная:
_fold :: Monoid m => [m] -> m -- Не совсем Data.Foldable.fold
_fold = mconcat

-- В качестве реализации я взял правую свертку, так как она будет работать
-- на бесконечных списках. В библиотеке, вообще говоря, реализация совсем
-- другая.

-- Иногда у нас есть контейнер с типом - не моноидом, и функция, которая
-- преобразует элемент исходного типа в тип-моноид. Тогда можно сделать foldMap:
_foldMap :: Monoid m => (a -> m) -> [a] -> m -- Не совсем Prelude.foldMap
_foldMap f = _fold . map f

--------------------------------------------------------------------------------
-- СУММА И ПРОИЗВЕДЕНИЕ

-- Заметим, что числа являются моноидами как по сумме, так и по произведению,
-- поэтому для них нельзя однозначно объявить инстанс-моноид.

-- Для решения этой проблемы используют обертки Sum и Product:
newtype Sum a = Sum { getSum :: a }
newtype Product a = Product { getProduct :: a }

instance Num a => Semigroup (Sum a) where
    Sum x <> Sum y = Sum $ x + y
instance Num a => Monoid (Sum a) where mempty = Sum 0

instance Num a => Semigroup (Product a) where
    Product x <> Product y = Product $ x * y
instance Num a => Monoid (Product a) where mempty = Product 1

-- Теперь, имея эти два моноида, можно реализовать получение суммы и
-- произведения элементов списка:
_sum :: Num a => [a] -> a -- Не совсем Prelude.sum
_sum = getSum . _foldMap Sum

_product :: Num a => [a] -> a -- Не совсем Prelude.product
_product = getProduct . _foldMap Product

--------------------------------------------------------------------------------
-- МИНИМУМ И МАКСИМУМ

-- Точно так же можно поступить и для минимума с максимумом.

newtype Max a = Max { getMax :: a }
newtype Min a = Min { getMin :: a }

instance Ord a => Semigroup (Max a) where
    Max x <> Max y | x >= y    = Max x
                   | otherwise = Max y
instance (Ord a, Bounded a) => Monoid (Max a) where mempty = Max minBound

instance Ord a => Semigroup (Min a) where
    Min x <> Min y | x <= y    = Min x
                   | otherwise = Min y
instance (Ord a, Bounded a) => Monoid (Min a) where mempty = Min minBound

-- Чтобы не требовать контекста Bounded, реализуем функции для непустых списков:
_minimum :: Ord a => [a] -> a -- Не совсем Prelude.minimum
_minimum []       = errorWithoutStackTrace "Seminar08._minumum: empty list"
_minimum (x : xs) = getMin $ _foldr (<>) (Min x) $ map Min xs

_maximum :: Ord a => [a] -> a -- Не совсем Prelude.maximum
_maximum []       = errorWithoutStackTrace "Seminar08._maximum: empty list"
_maximum (x : xs) = getMax $ _foldr (<>) (Max x) $ map Max xs

-- Это в каком-то смысле даже разумно, так как странно искать минимум в пустом
-- списке. Но если очень хочется, можно написать версии с дополнительным
-- контекстом, которые будут возвращать минимальную / максимульную границу в
-- типе, только они будут применимы к меньшему количеству типов. А если нет
-- желания бросать ошибку, всегда можно использовать Maybe.

--------------------------------------------------------------------------------
-- КЛАСС ТИПОВ FOLDABLE

-- Оказывается, свертки можно определить не только для списков, но и для
-- некоторых других типов: Maybe, Either и даже кортежей (но тут есть некоторые
-- тонкости, связынные с кайндами).

-- В Haskell реализован класс типов Foldable, который как раз и объединяет все
-- типы, на которых можно осуществлять свертку.

-- Класс типов состоит из целых 16 функций, причем не все из них доступны
-- в Prelude.

class Foldable t where
    fold :: Monoid m => t m -> m -- Data.Foldable.fold
    foldMap :: Monoid m => (a -> m) -> t a -> m
    foldr :: (a -> b -> b) -> b -> t a -> b
    foldr' :: (a -> b -> b) -> b -> t a -> b -- Data.Foldable.foldr'
    foldl :: (b -> a -> b) -> b -> t a -> b
    foldl' :: (b -> a -> b) -> b -> t a -> b -- Data.List.foldl'
    foldr1 :: (a -> a -> a) -> t a -> a
    foldl1 :: (a -> a -> a) -> t a -> a
    toList :: t a -> [a]
    null :: t a -> Bool
    length :: t a -> Int
    elem :: Eq a => a -> t a -> Bool
    maximum :: Ord a => t a -> a
    minimum :: Ord a => t a -> a
    sum :: Num a => t a -> a
    product :: Num a => t a -> a

    -- Выше мы уже реализовали многие из этих функций для списков, поэтому мы
    -- и писали "не совсем" (и начинали имена с подчеркиваний): в библиотеке
    -- реализованы более общие функции, которые могут работать с разными типов.

    -- Обратите внимание, что тип t, который мы объявляем Foldable, имеет кайнд
    -- не *, как обычно, а * -> *, то есть это однопараметрический тип
    -- (по смыслу контейнера), который принимает тип (по смыслу элементов,
    -- содержащихся в этом контейнере).

    -- Если тип элемента из класса Eq, то становится доступна функция elem. Если
    -- из Ord, то maximum и minumum. Если это числа, то можно счиать сумму и
    -- произведения. Наконец, если есть функцию, превращающие элементы в объекты
    -- типов-моноиды, то можно делать fold или foldMap.

    -- Интересный факт: все функции из указанных выше, имеют реализацию по
    -- умолчанию, а для определения экземпляра класса типов Foldable досттаочно
    -- реализовать всего лишь одну функцию: либо foldr, либо foldMap.

    -- Рассмотрим возможные варианты реализай по умолчанию, используя только
    -- foldr, а затем покажем, как функцию foldr выразить через foldMap.

    -- Начнем с базовых функций контейнера:
    toList = foldr (:) []
    null   = foldr (\ _ _ -> True) False
    length = foldr (\ _ len -> len + 1) 0
    elem y = foldr (\ x isElem -> isElem || x == y) False

    -- Вообще говоря, имея toList, мы уже можем реализовать почти все оставшиеся
    -- функции с помощью тех, которые мы писали выше для списков. Но на всякий
    -- случай по крайней мере для некоторых функций мы обойдемся без этого.

    -- Свертки моноидов:
    fold      = foldr (<>) mempty -- То же, что mconcat в моноидах, кстати.
    foldMap f = foldr (\ x acc -> f x <> acc) mempty -- Функции map для t нет.

    -- Сумма и произведение:
    sum     = getSum . foldMap Sum
    product = getProduct . foldMap Product

    -- Если для функций требуется начальное значение, то сделаем все-таки
    -- с помощью списков:
    maximum = _maximum . toList
    minimum = _minimum . toList

    -- Строгие свертки и свертки без начального значения:
    foldl' f y = _foldl' f y . toList
    foldr' f y = _foldr' f y . toList
    foldr1 f   = _foldr1 f . toList
    foldl1 f   = _foldl1 f . toList

    -- На самом деле можно, разумеестя, можно и обойтись и без превращения в
    -- списки, если завернуть все элементы в Maybe и взять в качестве начального
    -- значения Nothing, а затем аккуратно переписать сворачивающую функцию.
    -- Собственно, так и сделано в стандартной библиотеке, чтобы работало
    -- эффективнее.

    -- Осталось всего две функции:
    foldr = foldrThroughFoldMap
    foldl = foldlThroughFoldMap

    -- Функции foldrThroughFoldMap и foldlThroughFoldMap будут реализованы ниже.
    -- Для этого нужно рассмотреть две вспомогательные концепции, поэтому стоит
    -- выделить их отдельно.

--------------------------------------------------------------------------------
-- ЭНДОМОРФИЗМЫ

-- В математике эндоморфизмом называют функции, область значений которых
-- является подмножеством области определения.

-- Соответственно, в Haskell это просто преобразование объекта в рамках того же
-- типа:
newtype Endo a = Endo { appEndo :: a -> a }

-- Оказывается, эндоморфизмы являются монодидами с нейтральным элементом id
-- и операцией композиции:
instance Semigroup (Endo a) where
    Endo f <> Endo g = Endo $ f . g
instance Monoid (Endo a) where mempty = Endo id

--------------------------------------------------------------------------------
-- РЕАЛИЗАЦИЯ ПРАВОЙ СВЕРТКИ ЧЕРЕЗ FOLDMAP

-- Теперь с помощью эндоморфизмом можно реализовать правую свертку, используя
-- всего лишь foldMap:
foldrThroughFoldMap :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldrThroughFoldMap f y xs = appEndo (foldMap makeEndo xs) y
    where makeEndo = Endo . f

-- Начнем разбираться, как это работает.

-- f :: a -> b -> b = a -> (b -> b) - то есть функция f по элементу контейнера
-- возвращает какой-то эндоморфзм. Значит, Enfo . f :: a -> Endo b.

-- Таким образом, foldMap получит по каждому элементу эндоморфизм и сделает их
-- свертку, то есть получит в конце какой-то новый эндоморфизм типа Endo b. Для
-- применения функции foldMap как раз важно, что эндоморфизмы являются
-- моноидами.

-- Наконец, применяя свертку эндоморфизмов к начальному значению y :: b и
-- извлекая результат из обертки Endo, получаем свертку контейнера.

-- По типам все сходится, но почему получилась именно корректная свертка
-- контейнера?

-- Для этого достаточно развернуть левую часть по определению правой свертки:
--   foldr f y [x1, x2, ..., xN] =
-- = f x1 (f x2 (...(f xN y)...)) =
-- = (f x1 . f x2 . ... . f xN) y =
-- = appEndo (Endo (f x1) <> Endo (f x2) <> ... <> Endo (f xN)) y =
-- = | Так как композиция ассоциавтина, то как раз получается foldMap | =
-- = appEndo (foldMap (Endo . f) [x1, x2, ..., xN]) y

--------------------------------------------------------------------------------
-- ДУАЛЬНЫЕ МОНОИДЫ

-- Для реализации левой свертки по сути единственное, что нужно сделать, это
-- обратить порядок элементов в функции foldMap. Для такой цели можно
-- тип Dual, который как раз и отличается тем, что если в него обернуть
-- полугруппу, то порядок элементов в применении операции будет обратный.

newtype Dual a = Dual { getDual :: a }

instance Semigroup a => Semigroup (Dual a) where
    Dual x <> Dual y = Dual $ y <> x
instance Monoid a => Monoid (Dual a) where mempty = Dual mempty

--------------------------------------------------------------------------------
-- РЕАЛИЗАЦИЯ ЛЕВОЙ СВЕРТКИ ЧЕРЕЗ FOLDMAP

-- Теперь, чтобы реализовать левую свертку через foldMap, необходимо
-- воспользоваться той же идеей, что и для правой свертки, но обернуть каждый
-- эндоморфизм в Dual, чтобы развернуть список. Для этого дополнительно придется
-- поменять аргументы сворачивающей функции местами:
foldlThroughFoldMap :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldlThroughFoldMap f y xs = appDualEndo (foldMap makeDualEndo xs) y
    where
        makeDualEndo = Dual . Endo . flip f
        appDualEndo = appEndo . getDual

-- Идея объяснения точно та же, только теперь меняется порядок обхода списка.

-- Обратите внимание: вообще говоря, имея реализацию левой свертки через foldMap
-- и foldMap через правую свертку, можно реализовать левую свертку через правую
-- всего лишь простой подстановкой. А казалось бы, принципиально разные свертки.

--------------------------------------------------------------------------------
-- ЗАКОНЫ ДЛЯ FOLDABLE-ТИПОВ

-- Экземпляры класса типов Foldable должны удовлетворять четырем законам:
-- * foldr f z t = appEndo (foldMap (Endo . f) t) z
-- * foldl f z t = appEndo (getDual (foldMap (Dual . Endo . flip f) t)) z
-- * fold        = foldMap id
-- * length      = getSum . foldMap (Sum . const 1)

-- Первые два из них соответствуют нашей реализации, третий - очевиден, а
-- четвертый - еще один способ посчитать длину.

-- Кроме этих законов, требуется, чтобы функции maximum, minimum, sum, product
-- были эквивалентны по значениям функциям:
-- * sum     = getSum . foldMap Sum
-- * product = getProduct . foldMap Product
-- * maximum = getMax . foldMap max
-- * minimum = getMin . foldMap min
-- При этом допускается, чтобы функции справа могут быть менее определены, чем
-- функции слева (как раз уточнение насчет Bounded-типов).

-- (На будущее: для Foldable есть еще одно требование, если тип также является
-- функтором. Но функторы мы изучим в следующий раз.)

-- Для завершения знакомства с классом типов Foldable стоит отметить, что
-- не все функции реализованы так, как мы приводим, так как для многих типов
-- допустимы различные оптимизации.

--------------------------------------------------------------------------------
-- СПЕЦИАЛЬНЫЕ СВЕРТКИ

-- Помимо функций, определенных в классе типов, в Prelude есть также
-- специальные свертки, доступные из Prelude.

-- Работа с контейнерами булевых значений:
and :: Foldable t => t Bool -> Bool -- Prelude.and
and = getAll . foldMap All

all :: Foldable t => (a -> Bool) -> t a -> Bool -- Prelude.all
all p = getAll . foldMap (All . p)

-- Здесь обертка All определена следующим образом:
newtype All = All { getAll :: Bool }
instance Semigroup All where All x <> All y = All $ x && y
instance Monoid All where mempty = All True

-- Аналогично определяются функции Prelude.or, Prelude.any и обертка Any:
or :: Foldable t => t Bool -> Bool -- Prelude.or
or = getAny . foldMap Any

any :: Foldable t => (a -> Bool) -> t a -> Bool -- Prelude.any
any p = getAny . foldMap (Any . p)

newtype Any = Any { getAny :: Bool }
instance Semigroup Any where Any x <> Any y = Any $ x || y
instance Monoid Any where mempty = Any False

-- Есть класс сверток для работы со списками:
concat :: Foldable t => t [a] -> [a] -- Prelude.concat
concat = fold

concatMap :: Foldable t => (a -> [b]) -> t a -> [b] -- Prelude.concatMap
concatMap = foldMap

-- В библиотеке используются более эффективная реализации, так как эти работают
-- за квадрат.

-- Последняя функция, которую мы рассмотрим, это notElem:
notElem :: (Eq a, Foldable t) => a -> t a -> Bool
notElem x = not . elem x

--------------------------------------------------------------------------------
-- СТАНДАРТНЫЕ FOLDABLE-ТИПЫ

-- Познакомимся теперь с некоторыми стандартными Foldable-типами. Из Prelude их
-- доступно всего 4, но можно придумать и больше.

-- Самый простой вариант - это список. Для него мы уже все реализовали.
instance Foldable [] where
    foldr = _foldr

-- Тип Maybe тоже можно сворачивать:
instance Foldable Maybe where
    foldr _ y Nothing  = y
    foldr f y (Just x) = f x y

-- Далее, мы знаем, что Either a b - это почти как Maybe, только Just x
-- переходит в Right x, а Nothing - в Left y. Кроме того, Either :: * -> * -> *,
-- а значит, если зафиксировать первый аргумент (каррирование типов!), можно
-- написать то же, что и для Maybe:
instance Foldable (Either a) where
    foldr _ y (Left _)  = y
    foldr f y (Right x) = f x y

-- Точно такой же трюк можно провести и для пары: фиксируем первый элемент
-- и делаем свертку по второму. Только здесь второй элемент всегда есть, поэтому
-- реализация упрощается.
instance Foldable ((,) a) where
    foldr f y (_, x) = f x y

--------------------------------------------------------------------------------
-- СВЕРТКИ ДЕРЕВЬЕВ

-- Пример нестандартного типа, по которому можно выполнять свертку, это
-- какое-нибудь дерево:
data Tree a = Empty
            | Leaf a
            | Node (Tree a) a (Tree a)

-- Тогда можно сделать свертку, например, таким образом:
instance Foldable Tree where
    foldMap :: Monoid m => (a -> m) -> Tree a -> m
    foldMap _ Empty = mempty
    foldMap f (Leaf x) = f x
    foldMap f (Node l x r) = foldMap f l <> f x <> foldMap f r

-- Теперь можно, например, посчитать число вершин в дереве:
five = length fifth
    where
        first  = Leaf 1
        second = Node first 2 Empty
        third  = Node Empty 3 second
        fourth = Node Empty 4 Empty
        fifth  = Node third 5 fourth
